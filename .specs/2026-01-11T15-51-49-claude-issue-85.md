# Implementation Plan: Fix "Failed to retrieve order details" Error on Order Confirmation Page

**Issue**: #85
**Created**: 2026-01-11T15:51:49
**Status**: Awaiting Approval
**Complexity**: Medium

## Overview

After placing an order, customers see the success message "Order Confirmed!" followed by an error message: "Failed to retrieve order details." Investigation reveals that orders ARE being created successfully in the database, but the success page fails to retrieve the order data from the API endpoint.

### Goals and Success Criteria

- ✅ Order confirmation page successfully retrieves and displays order number after payment
- ✅ No false error messages shown to customers
- ✅ Proper error handling with appropriate user messages if genuine failures occur
- ✅ All existing tests continue to pass
- ✅ New tests verify the fix prevents regression

### Root Cause Analysis

The issue occurs in the `/shoppe/checkout/success` page flow:

1. **User completes payment** → Stripe redirects to `/shoppe/checkout/success?session_id={CHECKOUT_SESSION_ID}`
2. **Success page calls** → `GET /api/checkout/session/{sessionId}`
3. **API route queries database** → Looking for order with matching `payment_intent_id`
4. **Race condition occurs** → API query executes BEFORE webhook creates the order

**The Problem**: The success page redirect happens immediately after payment, but the webhook that creates the order in the database may not have fired yet (or may still be processing). This creates a race condition where the success page tries to fetch an order that doesn't exist yet.

**Evidence**:

- Orders ARE being created (confirmed by database checks in issue description)
- Error message shows on BOTH dev and live sites (consistent behavior)
- Error message is "Failed to retrieve order details" (from line 36 in `success/page.tsx`)
- API returns 404 or 500 when order not found (lines 48-52 in `session/[sessionId]/route.ts`)

### Technical Architecture

**Current Flow** (broken):

```
Payment Success → Redirect to /success?session_id=XXX
                ↓ (immediate)
              API call to /api/checkout/session/XXX
                ↓
              Query DB for payment_intent_id
                ↓
              ❌ Order not found (webhook hasn't run yet)
                ↓
              Display error message

Meanwhile (async):
Stripe Webhook → checkout.session.completed
                ↓
              Create order in database
                ↓
              ✅ Order exists (but too late)
```

**Target Flow** (fixed):

```
Payment Success → Redirect to /success?session_id=XXX
                ↓ (immediate)
              Poll API every 2 seconds (max 10 attempts)
                ↓
              Query DB for payment_intent_id
                ↓
              ❌ Not found? Wait and retry
                ↓
              ✅ Found! Display order number

Meanwhile (async):
Stripe Webhook → checkout.session.completed
                ↓
              Create order in database
                ↓
              ✅ Polling catches the order when it appears
```

## Technical Approach

### Solution Strategy: Polling with Timeout

Implement a **polling mechanism** on the success page that retries the API call multiple times with exponential backoff, giving the webhook time to complete order creation.

**Why Polling?**

- ✅ Simple to implement (client-side only change)
- ✅ No infrastructure changes required (no websockets, SSE, etc.)
- ✅ Handles webhook delays gracefully (network latency, Stripe processing time)
- ✅ Degrades gracefully if order creation truly fails
- ✅ User sees loading state instead of error

**Alternative Approaches Considered**:

1. **Server-Side Rendering with delay**: Would block the page load, poor UX
2. **WebSocket/SSE**: Over-engineered for this simple use case
3. **Remove order number display**: Loses valuable customer feedback
4. **Synchronous order creation in API**: Would slow down checkout, duplicate webhook logic

### SOLID Principles Application

1. **Single Responsibility Principle (SRP)**:
    - `useOrderPolling` hook: Handles ONLY polling logic (retry, backoff, timeout)
    - `CheckoutSuccessContent`: Handles ONLY UI rendering based on polling state
    - API route: Handles ONLY database query and response formatting

2. **Open/Closed Principle (OCP)**:
    - Polling parameters (interval, max attempts, backoff) are configurable constants
    - Can extend polling strategy (e.g., exponential backoff) without changing component logic

3. **Liskov Substitution Principle (LSP)**:
    - `useOrderPolling` returns consistent interface regardless of success/failure
    - Can swap polling implementations (e.g., WebSocket-based) without changing consumer

4. **Interface Segregation Principle (ISP)**:
    - Hook exposes only necessary state: `{ orderNumber, loading, error }`
    - Doesn't force consumers to depend on internal polling state

5. **Dependency Inversion Principle (DIP)**:
    - Component depends on abstract hook interface, not concrete fetch implementation
    - Can inject different API clients for testing

### Architecture Decision: Custom Hook vs Inline Logic

**Decision**: Extract polling logic into a custom React hook `useOrderPolling`.

**Rationale**:

- **Reusability**: Can be used in other scenarios requiring order retrieval
- **Testability**: Hook can be unit tested independently from UI
- **Separation of Concerns**: Polling logic separated from rendering logic
- **Single Responsibility**: Hook does polling, component does rendering

## Implementation Steps

### Step 1: Create Feature Branch

```bash
git checkout -b issue-85-fix-order-retrieval-error
```

**Rationale**: Isolate changes for clean PR review and easy rollback if needed.

---

### Step 2: Write Tests for Polling Hook (TDD Red Phase)

**Files to modify**:

- `__tests__/hooks/useOrderPolling.test.tsx` (NEW)

**Test cases to write FIRST**:

```typescript
describe('useOrderPolling', () => {
    it('should return loading state initially when sessionId is provided');
    it('should fetch order successfully on first attempt');
    it('should retry fetching when API returns 404');
    it('should stop retrying after max attempts and set error');
    it('should not fetch when sessionId is null');
    it('should handle API errors (500, network failures)');
    it('should apply exponential backoff between retries');
    it('should cleanup polling on unmount');
});
```

**SOLID Application**:

- **SRP**: Tests verify ONLY polling behavior, not UI rendering
- **DIP**: Tests can mock fetch implementation

**Verification Commands** (run after writing tests):

```bash
tsc --noEmit
npx eslint --fix __tests__/hooks/useOrderPolling.test.tsx
npx prettier --write __tests__/hooks/useOrderPolling.test.tsx
npx vitest related run __tests__/hooks/useOrderPolling.test.tsx
```

**Expected Result**: Tests should FAIL (hook doesn't exist yet - Red phase)

---

### Step 3: Implement Polling Hook (TDD Green Phase)

**Files to create**:

- `src/hooks/useOrderPolling.ts` (NEW)

**Implementation approach**:

```typescript
/**
 * Custom hook to poll for order details with retry logic
 *
 * Handles race condition where success page loads before webhook creates order.
 * Polls API endpoint with exponential backoff until order found or max attempts reached.
 *
 * @param sessionId - Stripe checkout session ID (null to skip polling)
 * @returns { orderNumber, loading, error } - Polling state
 */
export function useOrderPolling(sessionId: string | null): {
    orderNumber: string | null;
    loading: boolean;
    error: string | null;
};

// Constants (configurable for testing)
const INITIAL_RETRY_DELAY_MS = 1000; // Start with 1 second
const MAX_RETRY_ATTEMPTS = 10; // Max 10 attempts = ~20 seconds total
const BACKOFF_MULTIPLIER = 1.5; // Exponential backoff factor

// Implementation:
// 1. Use useEffect with sessionId dependency
// 2. Implement polling with setTimeout
// 3. Track attempt count and calculate backoff delay
// 4. Handle fetch success (200), not found (404), and errors (500, network)
// 5. Cleanup timers on unmount or success
```

**SOLID Application**:

- **SRP**: Hook handles ONLY polling logic
- **OCP**: Polling parameters are constants (can be made props if needed)
- **DIP**: Uses fetch abstraction (can be swapped for testing)

**Verification Commands**:

```bash
tsc --noEmit
npx eslint --fix src/hooks/useOrderPolling.ts
npx prettier --write src/hooks/useOrderPolling.ts
npx vitest related run __tests__/hooks/useOrderPolling.test.tsx
```

**Expected Result**: Tests should PASS (Green phase)

---

### Step 4: Refactor Hook for Better Error Handling (TDD Refactor Phase)

**Refactoring opportunities**:

- Extract retry delay calculation into pure function `calculateRetryDelay(attemptNumber)`
- Extract fetch logic into `fetchOrderBySession(sessionId)` for easier testing
- Add TypeScript discriminated union for error types (not found vs API error)

**Add additional tests**:

```typescript
describe('useOrderPolling - Refactored', () => {
    it('should distinguish between "not found yet" and "API error" states');
    it('should expose retry attempt count for debugging');
});
```

**SOLID Application**:

- **SRP**: Pure functions for delay calculation and fetching
- **OCP**: Error types can be extended without changing hook logic

**Verification Commands**:

```bash
tsc --noEmit
npx eslint --fix src/hooks/useOrderPolling.ts
npx prettier --write src/hooks/useOrderPolling.ts
npx vitest related run __tests__/hooks/useOrderPolling.test.tsx
```

**Expected Result**: All tests still pass, code is cleaner

---

### Step 5: Update Success Page to Use Polling Hook (TDD Red → Green)

**Files to modify**:

- `src/app/shoppe/checkout/success/page.tsx`
- `__tests__/app/shoppe/checkout/success/page.test.tsx`

**Phase 5a: Write Tests FIRST (Red)**

Add tests to existing test file:

```typescript
describe('CheckoutSuccessPage - Order Retrieval', () => {
    it('should show loading state while polling for order');
    it('should display order number when polling succeeds');
    it('should show error message when polling exhausts retries');
    it('should handle session_id query parameter correctly');
    it('should not poll when session_id is missing');
});
```

**Verification Commands**:

```bash
tsc --noEmit
npx eslint --fix __tests__/app/shoppe/checkout/success/page.test.tsx
npx prettier --write __tests__/app/shoppe/checkout/success/page.test.tsx
npx vitest related run __tests__/app/shoppe/checkout/success/page.test.tsx
```

**Expected Result**: New tests FAIL (hook not integrated yet)

**Phase 5b: Implement Changes (Green)**

Replace the existing `useEffect` fetch logic in `CheckoutSuccessContent` with:

```typescript
const { orderNumber, loading, error } = useOrderPolling(sessionId);
```

Remove:

- `useState` for `orderNumber`, `loading`, `error`
- `useEffect` with fetch logic

**SOLID Application**:

- **SRP**: Component now only handles rendering, not data fetching
- **DIP**: Component depends on hook abstraction, not fetch implementation

**Verification Commands**:

```bash
tsc --noEmit
npx eslint --fix src/app/shoppe/checkout/success/page.tsx
npx prettier --write src/app/shoppe/checkout/success/page.tsx
npx vitest related run __tests__/app/shoppe/checkout/success/page.test.tsx
```

**Expected Result**: All tests PASS

---

### Step 6: Update Error Messages for Better UX

**Files to modify**:

- `src/app/shoppe/checkout/success/page.tsx`

**Changes**:
Update error messaging to distinguish between:

1. **Polling timeout**: "We're still processing your order. You'll receive a confirmation email shortly."
2. **API error**: "Unable to retrieve order details right now. Don't worry - your payment was successful."

**No new tests needed** (covered by existing rendering tests)

**Verification Commands**:

```bash
tsc --noEmit
npx eslint --fix src/app/shoppe/checkout/success/page.tsx
npx prettier --write src/app/shoppe/checkout/success/page.tsx
npx vitest related run __tests__/app/shoppe/checkout/success/page.test.tsx
```

---

### Step 7: Add Integration Test for Full Flow

**Files to create**:

- `__tests__/app/shoppe/checkout/success/integration.test.tsx` (NEW)

**Test scenario**:

```typescript
describe('Checkout Success Page - Integration', () => {
    it(
        'should successfully display order after polling when webhook creates order'
    );
    it('should handle race condition where order appears on 3rd poll attempt');
    it('should show final error after max retries when order never appears');
});
```

Mock the API to simulate:

1. First 2 calls: Return 404 (order not found yet)
2. Third call: Return 200 with order data (webhook completed)

**Verification Commands**:

```bash
tsc --noEmit
npx eslint --fix __tests__/app/shoppe/checkout/success/integration.test.tsx
npx prettier --write __tests__/app/shoppe/checkout/success/integration.test.tsx
npx vitest related run __tests__/app/shoppe/checkout/success/integration.test.tsx
```

---

### Step 8: Manual Testing Checklist

Test on local dev environment:

**Test Case 1: Normal Flow (webhook faster than polling)**

1. Add item to cart
2. Complete checkout with test card `4242 4242 4242 4242`
3. Observe success page
4. **Expected**: Order number appears immediately or within 2 seconds

**Test Case 2: Delayed Webhook (simulated)**

1. Temporarily disable webhook processing (comment out order creation)
2. Complete checkout
3. Observe success page shows "Loading order details..." for ~20 seconds
4. Re-enable webhook, manually trigger order creation
5. **Expected**: Should show friendly message about email confirmation

**Test Case 3: No session_id Parameter**

1. Manually navigate to `/shoppe/checkout/success` (no query param)
2. **Expected**: Shows success message but no loading state, no error

**Test Case 4: Invalid session_id**

1. Navigate to `/shoppe/checkout/success?session_id=invalid`
2. **Expected**: Shows error message after retries exhausted

---

### Step 9: Update Documentation

**Files to modify**:

- `src/app/shoppe/checkout/success/page.tsx` (JSDoc comments)
- `src/hooks/useOrderPolling.ts` (JSDoc comments)

**Documentation to add**:

- Explain polling strategy in page component JSDoc
- Document retry parameters in hook JSDoc
- Add code example showing hook usage

**No verification needed** (documentation only)

---

### Step 10: Request Human Review

**Checklist for review**:

- [ ] All tests pass (`npm test`)
- [ ] No linting errors (`npm run lint`)
- [ ] Code is formatted (`npm run format`)
- [ ] TypeScript compiles (`tsc --noEmit`)
- [ ] Manual testing completed (all test cases pass)
- [ ] Browser console has no errors during checkout flow
- [ ] Error messages are user-friendly (no technical jargon)

**Review focus areas**:

1. Polling parameters (1s initial delay, 10 max attempts) - are these appropriate?
2. Error message wording - is it clear and reassuring?
3. Race condition handling - does polling solve the problem completely?
4. Performance impact - is polling acceptable for production?

---

### Step 11: Create Pull Request

**PR Title**: `fix: Resolve order retrieval race condition on success page (Issue #85)`

**PR Description**:

```markdown
## Summary

Fixes issue where customers see "Failed to retrieve order details" after successful payment.

## Root Cause

Race condition: Success page loads before webhook creates order in database.

## Solution

Implemented polling mechanism with exponential backoff to wait for webhook completion.

## Changes

- ✅ New `useOrderPolling` hook with retry logic (10 attempts, ~20s total)
- ✅ Updated success page to use polling instead of single fetch
- ✅ Improved error messages to distinguish timeout vs API errors
- ✅ Added comprehensive tests (unit + integration)

## Testing

- [x] Unit tests for polling hook
- [x] Integration tests for success page
- [x] Manual testing with real Stripe checkout (dev environment)
- [x] All existing tests pass

## Performance Impact

Minimal - polling only occurs on success page after payment (low traffic).

## Deployment Notes

No database migrations required. No environment variable changes.
```

**Verification Commands**:

```bash
npm run build:full
```

**Expected Result**: Build succeeds, all checks pass

---

### Step 12: After PR Approval - Squash and Merge

**Merge strategy**: Squash and merge

**Commit message**:

```
fix: Resolve order retrieval race condition on success page (#85)

- Add useOrderPolling hook with exponential backoff retry logic
- Update checkout success page to poll for order instead of single fetch
- Improve error messages to distinguish webhook delay from API errors
- Add comprehensive unit and integration tests

Fixes race condition where success page loaded before webhook created order,
causing false "Failed to retrieve order details" error message.

Polling tries up to 10 times over ~20 seconds, giving webhook time to complete.
Degrades gracefully with user-friendly message if order creation truly fails.
```

---

## Verification Process

After **EACH** implementation step above:

1. **Identify modified files** in the current step
2. **Run verification commands** with actual file paths:
    ```bash
    tsc --noEmit                                    # TypeScript check (all files)
    npx eslint --fix <file1.ts> <file2.tsx>        # ESLint specific files
    npx prettier --write <file1.ts> <file2.tsx>    # Prettier specific files
    npx vitest related run <test-file.test.tsx>    # Tests for specific files
    ```
3. **If any command fails**:
    - Fix the specific error immediately
    - Re-run the failed verification command
4. **If failures persist after 3 attempts**:
    - **STOP IMPLEMENTATION**
    - Document the issue clearly
    - Ask for human guidance with:
        - The failing command and output
        - What you tried to fix it
        - Why you think it's failing
5. **Only proceed to next step when ALL verifications pass**

---

## Testing Strategy (TDD Approach)

### Test-Driven Development Workflow

For **each** implementation step:

1. **Red Phase**: Write failing tests FIRST
    - Define expected behavior before implementation
    - Tests should fail because feature doesn't exist yet
    - Run `vitest` to confirm tests fail

2. **Green Phase**: Implement minimum code to pass tests
    - Write just enough code to make tests pass
    - No premature optimization
    - Run `vitest` to confirm tests pass

3. **Refactor Phase**: Improve code while keeping tests green
    - Extract functions, improve naming, reduce duplication
    - Run `vitest` after each refactoring step
    - Tests should still pass after refactoring

### Unit Tests (Written FIRST)

**Test file**: `__tests__/hooks/useOrderPolling.test.tsx`

**Coverage goals**:

- ✅ Initial loading state
- ✅ Successful fetch on first attempt
- ✅ Retry on 404 responses
- ✅ Max retry limit enforcement
- ✅ Error handling (500, network errors)
- ✅ Exponential backoff timing
- ✅ Cleanup on unmount
- ✅ Skipping when sessionId is null

**Testing approach**:

- Mock `fetch` API responses
- Use `vi.useFakeTimers()` to control async timing
- Test hook with `@testing-library/react-hooks` or `renderHook`

### Integration Tests (Written FIRST)

**Test file**: `__tests__/app/shoppe/checkout/success/integration.test.tsx`

**Scenarios**:

- ✅ Order appears immediately (webhook completed before page load)
- ✅ Order appears after 2-3 retries (webhook completes during polling)
- ✅ Order never appears (webhook failed, exhaust retries)
- ✅ Invalid session ID handling

**Testing approach**:

- Mock API route responses with sequence: [404, 404, 200]
- Render full component tree with providers
- Assert on loading → success state transitions
- Use `waitFor` to handle async state updates

### Manual Testing Scenarios

**Scenario 1: Happy Path**

- Place test order with card `4242 4242 4242 4242`
- Verify order number appears within 2 seconds
- Check browser console for no errors
- Verify order exists in database

**Scenario 2: Webhook Delay (Simulated)**

- Temporarily slow down webhook processing (add delay in webhook handler)
- Place order
- Observe polling retry behavior in Network tab
- Verify success after webhook completes

**Scenario 3: Edge Cases**

- Missing session_id parameter
- Invalid/expired session_id
- Network errors during polling
- Browser navigation away during polling (cleanup verification)

### Regression Testing

Run **full test suite** before PR submission:

```bash
npm test              # All unit + integration tests
npm run build:full    # Type check + lint + test + build
```

All existing tests must pass - no breaking changes allowed.

---

## Security & Performance Considerations

### Security

- **No new attack surface**: Polling uses existing authenticated API endpoint
- **Rate limiting**: 10 max attempts prevents abuse (could add client-side throttle if needed)
- **Data exposure**: No sensitive data in error messages (payment confirmed, email sent)
- **CSRF protection**: Existing API route CSRF protection remains unchanged

### Performance

- **Client-side polling**: ~10-20 API calls per successful checkout (acceptable low-traffic scenario)
- **Exponential backoff**: Reduces server load over time (1s, 1.5s, 2.25s delays)
- **Early exit**: Stops polling immediately on success (no unnecessary requests)
- **No impact on failed checkouts**: Only polls when `session_id` present (successful payment)

**Production metrics to monitor**:

- Average polling attempts before success (should be 1-2)
- Polling timeout rate (should be <1% of orders)
- API response times for `/api/checkout/session/[id]` (should remain <200ms)

### Database Impact

- **No schema changes**: Uses existing `payment_intent_id` unique constraint
- **No additional indexes**: Query already optimized with index from migration 002
- **Read-only operations**: Polling only queries, doesn't modify data

---

## Backward Compatibility

- ✅ No breaking changes to API endpoints
- ✅ Existing webhook logic unchanged
- ✅ Database schema unchanged
- ✅ Error messages backward compatible (still show reassuring fallback)
- ✅ Success page still works if JavaScript disabled (shows generic success, no order number)

---

## Rollback Plan

If issues arise after deployment:

1. **Immediate rollback**: Revert PR merge (git revert)
2. **Partial rollback**: Feature flag to disable polling (requires code change)
3. **Database rollback**: Not needed (no migrations)

**Monitoring**: Watch for increased API errors, slower success page loads, customer complaints

---

## Documentation Updates

### Code Documentation

**Files to update**:

- `src/hooks/useOrderPolling.ts`: Comprehensive JSDoc with examples
- `src/app/shoppe/checkout/success/page.tsx`: Update component JSDoc to explain polling

**Documentation to include**:

- Purpose of polling (race condition mitigation)
- Retry parameters and rationale
- Error handling strategy
- Usage examples

### Project Documentation

**No updates required** - this is an internal bug fix, not a feature addition.

**Optional**: Add note to `.docs/ARCHITECTURE.md` about webhook race condition handling if that doc exists.

---

## Open Questions (Address Before Implementation)

1. **Polling parameters**: Is 10 retries over ~20 seconds appropriate?
    - **Option A**: Current plan (10 retries, 1s initial, 1.5x backoff)
    - **Option B**: Longer timeout (20 retries, ~40 seconds total)
    - **Option C**: Shorter timeout (5 retries, ~10 seconds total)
    - **Recommendation**: Start with Option A, monitor production metrics, adjust if needed

2. **Error message wording**: Are the proposed messages clear and reassuring?
    - **Current**: "We're still processing your order. You'll receive a confirmation email shortly."
    - **Alternative**: "Your order is being processed. Check your email for confirmation."
    - **Recommendation**: User testing preferred, but current wording is acceptable

3. **Future enhancement**: Should we add real-time updates (WebSocket/SSE) in the future?
    - **Pros**: More responsive, better UX for edge cases
    - **Cons**: More complex, requires infrastructure changes
    - **Recommendation**: Defer until polling proves insufficient (monitor metrics)

---

## Success Metrics (Post-Deployment)

Track these metrics to validate the fix:

1. **Primary Metric**: % of success page loads that show "Failed to retrieve order details" error
    - **Before fix**: Unknown (100% based on issue report?)
    - **After fix target**: <1% (only genuine API failures)

2. **Secondary Metrics**:
    - Average polling attempts before success: Target 1-2 (most orders found immediately)
    - Polling timeout rate: Target <1% (webhook completes within 20s)
    - API endpoint latency: Should remain <200ms (no degradation)

3. **Customer-Facing Metrics**:
    - Checkout support tickets related to "order confirmation error": Should drop to 0
    - Customer satisfaction (CSAT) on checkout flow: Should improve

**Monitoring period**: 2 weeks post-deployment

---

## Dependencies

**No new npm packages required** - uses existing React hooks, fetch API, and setTimeout.

**Existing dependencies used**:

- React (useEffect, useState)
- Next.js (useSearchParams from next/navigation)
- TypeScript (for type safety)
- Vitest (for testing)

---

## Timeline Estimate (Implementation Time)

**Not estimating in hours/days per instruction** - this is a scope breakdown:

- Steps 2-4: Polling hook (TDD cycle)
- Steps 5-6: Success page integration (TDD cycle)
- Step 7: Integration tests
- Step 8: Manual testing
- Steps 9-12: Documentation, PR, merge

**All steps must be completed** regardless of time taken.

---

## Risks and Mitigation

| Risk                                 | Impact | Probability | Mitigation                                              |
| ------------------------------------ | ------ | ----------- | ------------------------------------------------------- |
| Polling doesn't solve race condition | High   | Low         | Integration tests simulate webhook delay                |
| Polling increases API load           | Medium | Low         | Exponential backoff, max 10 retries                     |
| Error messages confuse customers     | Medium | Medium      | User-friendly wording, fallback to email                |
| Tests don't cover edge cases         | High   | Medium      | Comprehensive test plan with multiple scenarios         |
| Webhook never fires (Stripe issue)   | High   | Very Low    | Error message directs to email, support can investigate |

---

## Alternatives Considered (Rejected)

### Alternative 1: Server-Side Polling

**Approach**: Wait for order in API route before responding
**Pros**: Single request from client
**Cons**: Blocks HTTP connection for 20+ seconds (bad practice), timeout issues, poor UX
**Rejection Reason**: Violates HTTP best practices, worse user experience

### Alternative 2: Remove Order Number Display

**Approach**: Just show generic success message
**Pros**: No race condition possible
**Cons**: Customers lose immediate confirmation, support burden increases
**Rejection Reason**: Degrades user experience, order number is valuable feedback

### Alternative 3: Synchronous Order Creation

**Approach**: Create order in checkout API, not webhook
**Pros**: No race condition, order always available
**Cons**: Duplicates logic, webhook still creates duplicate orders, violates Stripe best practices
**Rejection Reason**: Architectural complexity, duplicate order risk

### Alternative 4: WebSocket/Server-Sent Events

**Approach**: Real-time notification when order created
**Pros**: Instant updates, better UX
**Cons**: Infrastructure complexity, overkill for this use case
**Rejection Reason**: Over-engineered, polling is sufficient for low-traffic scenario

---

## Conclusion

This plan addresses the root cause (race condition between success page load and webhook execution) with a simple, testable polling solution. The TDD approach ensures robust test coverage, and the verification process prevents regressions. SOLID principles keep the code maintainable and extensible.

**Next Step**: Await human approval before proceeding with implementation.
