# Implementation Plan: Contact Form Email Notification

**Issue:** #106 - Send an email to the site admin when someone submits the form on the Contact page

**Created:** 2026-01-17T21:05:57

**Status:** Approved - Ready for Implementation

---

## Approved Decisions

The following decisions have been approved by the human reviewer:

1. **TDD Approach:** Use Test-Driven Development (Red-Green-Refactor) whenever it makes sense for the implementation
2. **Button Variant:** Create new `primary-dark` variant for buttons on black backgrounds (all other buttons are on white backgrounds)
3. **Error Handling:** Always show success message to user even if email fails (graceful degradation)
4. **Future Enhancement:** Database table for storing contact messages will be added later (out of scope for this issue)
5. **Testing Coverage:** Planned testing strategy is sufficient

---

## Overview

This implementation adds email functionality to the existing contact form on `/contact`, sending form submissions to the site admin via Resend API. The project already has a robust email infrastructure used for order confirmations, which we'll leverage and extend for contact form notifications.

### Goals and Success Criteria

1. âœ… Contact form submissions send email to `joe@yeoldeartoonist.com`
2. âœ… Send Message button is visually distinguishable with white border (`#ffffff`)
3. âœ… Phase 4 note removed from contact page
4. âœ… Professional email template for contact form submissions
5. âœ… Proper error handling for email failures
6. âœ… All existing tests pass + new tests for email functionality
7. âœ… Form remains functional if email delivery fails (graceful degradation)

### Estimated Scope and Complexity

**Complexity:** Medium

**Rationale:**

- Existing email infrastructure reduces complexity
- Email template creation follows established patterns
- API route creation is straightforward with existing examples
- Button styling change is trivial
- Main complexity: comprehensive testing and error handling

---

## Technical Approach

### Architectural Decisions and Rationale

#### 1. API Route Pattern

**Decision:** Create `/api/contact` POST endpoint following existing API patterns

**Rationale:**

- Consistent with existing API routes (`/api/checkout/*`, `/api/admin/*`)
- Server-side email sending prevents API key exposure
- Enables proper error handling and logging
- Follows Next.js 16 App Router conventions

**SOLID Principles Applied:**

- **Single Responsibility:** API route handles only contact form submission and email sending
- **Dependency Inversion:** Route depends on email service abstraction, not concrete implementation

#### 2. Email Template Design

**Decision:** Create dedicated `ContactFormSubmission.tsx` React Email template

**Rationale:**

- Follows existing pattern (`OrderConfirmation.tsx`, `AdminNotification.tsx`)
- Maintainable, type-safe email design
- Consistent branding across all email communications
- Easy to preview and test with React Email tooling

**SOLID Principles Applied:**

- **Single Responsibility:** Template responsible only for rendering contact email
- **Open/Closed:** Template extensible for future contact form fields without modification to email service

#### 3. Email Service Extension

**Decision:** Add `sendContactFormEmail()` function to existing `src/lib/email/send.ts`

**Rationale:**

- Centralized email logic in single module
- Reuses existing error handling, logging, and Resend configuration
- Consistent return type (`EmailResult`) across all email operations
- No duplication of Resend client initialization

**SOLID Principles Applied:**

- **Single Responsibility:** Email service handles email sending concerns only
- **Open/Closed:** Extended with new function without modifying existing ones
- **Interface Segregation:** Each email function has specific purpose

#### 4. Error Handling Strategy

**Decision:** Non-blocking email failures with user-friendly fallback - always show success to user

**Rationale:**

- Form submission should succeed even if email fails (network issues, Resend downtime)
- Log failures server-side for debugging
- Show success message to user regardless (better UX than cryptic error)
- User can retry or contact directly via email if needed
- **Future Enhancement:** Database table will be added to store all contact form submissions as a fallback (out of scope for this issue)

**SOLID Principles Applied:**

- **Dependency Inversion:** Form doesn't depend on email success, only on API response

#### 5. Button Styling Approach

**Decision:** Create new `primary-dark` button variant for buttons on black backgrounds

**Rationale:**

- Contact page has black background (`bg-black`)
- Current primary button: black background + black border = invisible on dark backgrounds
- All other buttons in the app are on white backgrounds and work fine with `primary` variant
- Creating new variant (`primary-dark`) avoids breaking existing button usage
- New variant will have white border (`border-white`) for visibility on black backgrounds

**SOLID Principles Applied:**

- **Open/Closed:** Extend Button component with new variant without modifying existing behavior
- **Single Responsibility:** Each variant serves a specific visual context

### Integration Points with Existing Code

1. **Email Service (`src/lib/email/send.ts`):** Add new function following established patterns
2. **Button Component (`src/components/ui/Button.tsx`):** Update primary variant styling
3. **Contact Client (`src/app/contact/ContactClient.tsx`):** Add API call in `handleSubmit`
4. **Environment Variables:** Leverage existing `RESEND_API_KEY` and `ADMIN_EMAIL`

### Potential Risks and Mitigation Strategies

| Risk                              | Mitigation                                                                                   |
| --------------------------------- | -------------------------------------------------------------------------------------------- |
| Email delivery failures           | Non-blocking errors, comprehensive logging, user-friendly fallback messaging                 |
| Button styling breaks other pages | Audit all uses of `variant="primary"` before change; consider creating new variant if needed |
| Form spam/abuse                   | Rate limiting (future enhancement, out of scope)                                             |
| Missing environment variables     | Validation in email service with clear error messages                                        |
| Email template rendering errors   | Comprehensive unit tests for template with various input scenarios                           |

---

## Implementation Steps

Each step follows TDD Red-Green-Refactor cycle and includes verification commands.

### Step 1: Create branch

```bash
git checkout -b issue-106
```

**Why:** Isolate work for clean PR and easy rollback if needed.

### Step 2: Create Contact Form Email Template (TDD Red Phase)

**Test First:** Write test for `ContactFormSubmission` template

**Files:**

- `__tests__/lib/email/contact-template.test.tsx` (NEW)

**Test Cases:**

1. Template renders with all required contact form fields
2. Template properly escapes user-provided content (XSS prevention)
3. Template handles missing optional fields gracefully
4. Template displays admin-friendly subject line
5. Template matches existing email styling patterns
6. Snapshot test for HTML output consistency

**Why:** Ensure email template is robust before writing implementation. Test-driven approach catches edge cases early.

**SOLID Principles:**

- **Single Responsibility:** Tests verify only template rendering concerns
- **Interface Segregation:** Test distinct aspects separately

**Verification Commands:**

```bash
tsc --noEmit
npx eslint --fix __tests__/lib/email/contact-template.test.tsx
npx prettier --write __tests__/lib/email/contact-template.test.tsx
npx vitest related run __tests__/lib/email/contact-template.test.tsx
```

**Expected Result:** Tests fail (Red phase) because template doesn't exist yet.

### Step 3: Implement Contact Form Email Template (TDD Green Phase)

**Files:**

- `src/lib/email/templates/ContactFormSubmission.tsx` (NEW)

**Implementation Details:**

- Use React Email components (`Html`, `Body`, `Container`, `Text`, `Section`, etc.)
- Display: name, email, message from form submission
- Include timestamp of submission
- Match styling of existing `AdminNotification.tsx` template
- Proper HTML escaping (React Email handles this automatically)

**Template Structure:**

```tsx
interface ContactFormSubmissionProps {
    name: string;
    email: string;
    message: string;
    submittedAt: string;
}

export function ContactFormSubmission({
    name,
    email,
    message,
    submittedAt,
}: ContactFormSubmissionProps) {
    // Render professional email with contact details
}
```

**Why:** Reusable, type-safe email template that integrates with existing email infrastructure.

**SOLID Principles:**

- **Single Responsibility:** Template only renders contact email HTML
- **Open/Closed:** Can add new fields via props without changing structure

**Verification Commands:**

```bash
tsc --noEmit
npx eslint --fix src/lib/email/templates/ContactFormSubmission.tsx
npx prettier --write src/lib/email/templates/ContactFormSubmission.tsx
npx vitest related run src/lib/email/templates/ContactFormSubmission.tsx
```

**Expected Result:** All tests pass (Green phase).

### Step 4: Refactor Email Template (TDD Refactor Phase)

**Refactoring Opportunities:**

1. Extract common email styles into shared constants (if not already done)
2. Ensure consistent spacing and typography across all email templates
3. Consider accessibility improvements (semantic HTML, alt text)

**Why:** Maintain code quality and consistency across email templates.

**SOLID Principles:**

- **DRY Principle:** Extract duplicated styling into shared constants
- **Open/Closed:** Make template easier to extend

**Verification Commands:**

```bash
tsc --noEmit
npx eslint --fix src/lib/email/templates/ContactFormSubmission.tsx
npx prettier --write src/lib/email/templates/ContactFormSubmission.tsx
npx vitest related run src/lib/email/templates/ContactFormSubmission.tsx
```

**Expected Result:** Tests still pass after refactoring.

### Step 5: Extend Email Service with Contact Form Function (TDD Red Phase)

**Test First:** Write tests for `sendContactFormEmail` function

**Files:**

- `__tests__/lib/email/send.test.ts` (MODIFY - add new tests)

**Test Cases:**

1. Successfully sends contact form email with valid data
2. Returns success result with message ID
3. Handles Resend API errors gracefully
4. Validates required environment variables (RESEND_API_KEY)
5. Uses ADMIN_EMAIL as recipient
6. Logs appropriate information for debugging
7. Returns error result when email sending fails
8. Includes proper error codes for different failure types

**Why:** Test-driven development ensures email service is robust and handles all edge cases.

**SOLID Principles:**

- **Single Responsibility:** Tests verify only email sending concerns
- **Dependency Inversion:** Tests can mock Resend client

**Verification Commands:**

```bash
tsc --noEmit
npx eslint --fix __tests__/lib/email/send.test.ts
npx prettier --write __tests__/lib/email/send.test.ts
npx vitest related run __tests__/lib/email/send.test.ts
```

**Expected Result:** New tests fail (Red phase) because function doesn't exist yet.

### Step 6: Implement sendContactFormEmail Function (TDD Green Phase)

**Files:**

- `src/lib/email/send.ts` (MODIFY - add new function)

**Implementation Details:**

```typescript
interface ContactFormData {
    name: string;
    email: string;
    message: string;
}

export async function sendContactFormEmail(
    contactData: ContactFormData
): Promise<EmailResult> {
    // 1. Validate email config (existing helper)
    // 2. Render ContactFormSubmission template
    // 3. Send email via Resend to ADMIN_EMAIL
    // 4. Return EmailResult with success/error
    // 5. Log appropriately for debugging
}
```

**Error Handling:**

- Catch Resend API errors â†’ `EmailSendError` with `RESEND_ERROR` code
- Catch rendering errors â†’ `EmailSendError` with `RENDER_ERROR` code
- Catch config errors â†’ `EmailSendError` with `CONFIG_ERROR` code
- Never throw, always return `EmailResult`

**Why:** Centralized email logic with consistent error handling and logging.

**SOLID Principles:**

- **Single Responsibility:** Function handles only contact email sending
- **Open/Closed:** Extends email service without modifying existing functions
- **Dependency Inversion:** Depends on Resend abstraction, not direct implementation

**Verification Commands:**

```bash
tsc --noEmit
npx eslint --fix src/lib/email/send.ts
npx prettier --write src/lib/email/send.ts
npx vitest related run src/lib/email/send.ts
```

**Expected Result:** All new tests pass (Green phase).

### Step 7: Refactor Email Service (TDD Refactor Phase)

**Refactoring Opportunities:**

1. Extract common error handling patterns into helper functions
2. Consider creating shared email validation logic
3. Ensure consistent logging format across all email functions

**Why:** Reduce duplication and improve maintainability.

**SOLID Principles:**

- **DRY Principle:** Extract repeated patterns
- **Single Responsibility:** Helper functions have focused purposes

**Verification Commands:**

```bash
tsc --noEmit
npx eslint --fix src/lib/email/send.ts
npx prettier --write src/lib/email/send.ts
npx vitest related run src/lib/email/send.ts
```

**Expected Result:** All tests still pass after refactoring.

### Step 8: Create API Route for Contact Form (TDD Red Phase)

**Test First:** Write tests for `/api/contact` endpoint

**Files:**

- `__tests__/app/api/contact/route.test.ts` (NEW)

**Test Cases:**

1. POST request with valid data sends email and returns 200
2. POST request with invalid data returns 400 validation error
3. POST request with missing fields returns 400 with specific error messages
4. POST request handles email service failures gracefully (returns 200 but logs error)
5. GET/PUT/DELETE requests return 405 Method Not Allowed
6. Request with missing RESEND_API_KEY returns 500 configuration error
7. Request validates email format
8. Request validates message length constraints
9. Request sanitizes user input to prevent injection attacks

**Why:** API route is the public interface; comprehensive testing ensures security and reliability.

**SOLID Principles:**

- **Single Responsibility:** Tests verify only API endpoint behavior
- **Interface Segregation:** Test each HTTP method and validation rule separately

**Verification Commands:**

```bash
tsc --noEmit
npx eslint --fix __tests__/app/api/contact/route.test.ts
npx prettier --write __tests__/app/api/contact/route.test.ts
npx vitest related run __tests__/app/api/contact/route.test.ts
```

**Expected Result:** Tests fail (Red phase) because route doesn't exist yet.

### Step 9: Implement API Route (TDD Green Phase)

**Files:**

- `src/app/api/contact/route.ts` (NEW)

**Implementation Details:**

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { sendContactFormEmail } from '@/lib/email/send';

// Request validation schema (reuse from ContactClient)
const contactFormSchema = z.object({
    name: z.string().min(1).max(100),
    email: z.string().email(),
    message: z.string().min(10).max(5000),
});

export async function POST(request: NextRequest) {
    try {
        // 1. Parse request body
        const body = await request.json();

        // 2. Validate with Zod schema
        const result = contactFormSchema.safeParse(body);
        if (!result.success) {
            return NextResponse.json(
                { error: 'Validation failed', details: result.error.issues },
                { status: 400 }
            );
        }

        // 3. Send email
        const emailResult = await sendContactFormEmail(result.data);

        // 4. Log result but always return success to user
        if (!emailResult.success) {
            console.error('Contact form email failed:', emailResult.error);
            // Still return 200 to prevent user-facing error
        }

        // 5. Return success response
        return NextResponse.json({ success: true }, { status: 200 });
    } catch (error) {
        console.error('Contact form API error:', error);
        return NextResponse.json(
            { error: 'Internal server error' },
            { status: 500 }
        );
    }
}

// Reject non-POST requests
export async function GET() {
    return NextResponse.json({ error: 'Method not allowed' }, { status: 405 });
}
```

**Why:** Secure, validated API endpoint with proper error handling.

**SOLID Principles:**

- **Single Responsibility:** Route handles only HTTP request/response and delegates to email service
- **Dependency Inversion:** Depends on email service abstraction
- **Open/Closed:** Easy to add additional processing (analytics, logging) without modifying core logic

**Verification Commands:**

```bash
tsc --noEmit
npx eslint --fix src/app/api/contact/route.ts
npx prettier --write src/app/api/contact/route.ts
npx vitest related run src/app/api/contact/route.ts
```

**Expected Result:** All tests pass (Green phase).

### Step 10: Refactor API Route (TDD Refactor Phase)

**Refactoring Opportunities:**

1. Extract validation schema to shared location if reused
2. Consider rate limiting middleware (out of scope, but note for future)
3. Improve error message clarity

**Why:** Improve code organization and maintainability.

**SOLID Principles:**

- **DRY Principle:** Avoid duplicating validation schema

**Verification Commands:**

```bash
tsc --noEmit
npx eslint --fix src/app/api/contact/route.ts
npx prettier --write src/app/api/contact/route.ts
npx vitest related run src/app/api/contact/route.ts
```

**Expected Result:** Tests still pass after refactoring.

### Step 11: Verify Button Component Usage (Informational Step)

**Investigation:**

```bash
# Find all uses of variant="primary" to confirm they're on white backgrounds
npx grep -r "variant=\"primary\"" src/
```

**Analysis:**

- Verify that all other uses of `variant="primary"` are on pages with white backgrounds
- Confirms our decision to create new `primary-dark` variant for black backgrounds
- Documents existing button usage for future reference

**Decision (Pre-approved):** Create new `primary-dark` variant for contact page

- All existing buttons use `primary` variant on white backgrounds
- Creating new variant avoids any risk of breaking existing pages
- Contact page is the only page with black background that needs a primary-style button

**Why:** Validate our architectural decision and document existing button usage.

**SOLID Principles:**

- **Open/Closed:** Creating new variant extends functionality without modifying existing behavior

**No verification commands needed** (research/documentation step only).

### Step 12: Add Button Component Tests for New Variant (TDD Red Phase)

**Test First:** Write/update tests for Button component to include new `primary-dark` variant

**Files:**

- `__tests__/components/ui/Button.test.tsx` (MODIFY or CREATE)

**Test Cases:**

1. Primary variant still renders with black border (unchanged)
2. New `primary-dark` variant renders with white border
3. New `primary-dark` variant has black background
4. New `primary-dark` variant has correct hover state
5. Other variants (secondary, outline) unchanged
6. All variants render without errors

**Why:** Prevent styling regressions and verify new variant works correctly.

**SOLID Principles:**

- **Single Responsibility:** Tests verify only button rendering
- **Open/Closed:** Testing extension without modification of existing variants

**Verification Commands:**

```bash
tsc --noEmit
npx eslint --fix __tests__/components/ui/Button.test.tsx
npx prettier --write __tests__/components/ui/Button.test.tsx
npx vitest related run __tests__/components/ui/Button.test.tsx
```

**Expected Result:** Tests fail (Red phase) because `primary-dark` variant doesn't exist yet.

### Step 13: Implement New Button Variant (TDD Green Phase)

**Files:**

- `src/components/ui/Button.tsx` (MODIFY)

**Implementation:**

Add new `primary-dark` variant to the Button component:

```typescript
export interface ButtonProps
    extends React.ButtonHTMLAttributes<HTMLButtonElement> {
    variant?: 'primary' | 'primary-dark' | 'secondary' | 'outline';
    size?: 'sm' | 'md' | 'lg';
    children: React.ReactNode;
}

const variantStyles = {
    primary: 'bg-black text-white hover:bg-gray-800 border-black',
    'primary-dark': 'bg-black text-white hover:bg-gray-800 border-white',
    secondary: 'bg-white text-black hover:bg-gray-100 border-black',
    outline: 'bg-transparent text-black hover:bg-gray-100 border-black',
};
```

**Why:** Make Send Message button visually distinguishable on black background without breaking existing button usage.

**SOLID Principles:**

- **Open/Closed:** Extends Button component with new variant without modifying existing behavior
- **Single Responsibility:** Each variant handles specific visual context

**Verification Commands:**

```bash
tsc --noEmit
npx eslint --fix src/components/ui/Button.tsx
npx prettier --write src/components/ui/Button.tsx
npx vitest related run src/components/ui/Button.tsx
```

**Expected Result:** All tests pass (Green phase).

### Step 14: Update Contact Form Client to Call API (TDD Red Phase)

**Test First:** Update contact page tests for API integration

**Files:**

- `__tests__/app/contact/page.test.tsx` (MODIFY)

**New Test Cases:**

1. Form submission calls `/api/contact` with correct data
2. Successful API response shows success message
3. API error (400/500) shows error message with helpful guidance
4. API call includes proper headers (Content-Type: application/json)
5. Form disables submit button during API call (loading state)
6. Form re-enables submit button after API response
7. Network error shows user-friendly message

**Why:** Ensure contact form integrates correctly with new API.

**SOLID Principles:**

- **Dependency Inversion:** Tests can mock fetch calls

**Verification Commands:**

```bash
tsc --noEmit
npx eslint --fix __tests__/app/contact/page.test.tsx
npx prettier --write __tests__/app/contact/page.test.tsx
npx vitest related run __tests__/app/contact/page.test.tsx
```

**Expected Result:** New tests fail (Red phase) because API integration not implemented yet.

### Step 15: Implement Contact Form API Integration (TDD Green Phase)

**Files:**

- `src/app/contact/ContactClient.tsx` (MODIFY)

**Implementation Details:**

```typescript
const [isSubmitting, setIsSubmitting] = useState(false);
const [error, setError] = useState<string | null>(null);

const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    // Validate form data
    const result = contactFormSchema.safeParse(formData);
    if (!result.success) {
        // ... existing validation error handling
        return;
    }

    setIsSubmitting(true);
    setError(null);

    try {
        // Call API
        const response = await fetch('/api/contact', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(result.data),
        });

        if (!response.ok) {
            throw new Error('Failed to send message');
        }

        // Show success message
        setSubmitted(true);
        setTimeout(() => {
            setSubmitted(false);
            setFormData({ name: '', email: '', message: '' });
            setErrors({});
        }, 3000);
    } catch (err) {
        console.error('Contact form submission error:', err);
        setError(
            'Unable to send message. Please email joe@yeoldeartoonist.com directly.'
        );
    } finally {
        setIsSubmitting(false);
    }
};
```

**UI Updates:**

- Update Button variant from `variant="primary"` to `variant="primary-dark"` (for white border visibility)
- Disable submit button when `isSubmitting` is true
- Show loading indicator during submission
- Display error message if API call fails
- Provide fallback contact method in error message

**Why:** Integrate form with backend while maintaining good UX.

**SOLID Principles:**

- **Single Responsibility:** Form handles only UI state and API calls
- **Dependency Inversion:** Form depends on API contract, not implementation

**Verification Commands:**

```bash
tsc --noEmit
npx eslint --fix src/app/contact/ContactClient.tsx
npx prettier --write src/app/contact/ContactClient.tsx
npx vitest related run src/app/contact/ContactClient.tsx
```

**Expected Result:** All tests pass (Green phase).

### Step 16: Remove Phase 4 Implementation Note

**Files:**

- `src/app/contact/ContactClient.tsx` (MODIFY)

**Change:**
Remove or update this section (around line 304-308):

```tsx
<p className="text-sm text-gray-400 mt-4">
    Note: Full email functionality will be implemented in Phase 4. For now, form
    submissions aren't sent.
</p>
```

**Replace with (optional):**

```tsx
<p className="text-sm text-gray-400 mt-4">
    I typically respond within 1-2 business days.
</p>
```

**Why:** AC #3 - Remove outdated implementation note.

**SOLID Principles:**

- **Open/Closed:** Update messaging without changing functionality

**Verification Commands:**

```bash
tsc --noEmit
npx eslint --fix src/app/contact/ContactClient.tsx
npx prettier --write src/app/contact/ContactClient.tsx
npx vitest related run src/app/contact/ContactClient.tsx
```

**Expected Result:** Tests pass; update test expectations for removed/changed text.

### Step 17: Update Contact Page Tests for Removed Note

**Files:**

- `__tests__/app/contact/page.test.tsx` (MODIFY)

**Changes:**

- Remove or update test case checking for "Phase 4" note (line 223-230)
- Update snapshot tests if applicable

**Why:** Keep tests aligned with updated UI.

**Verification Commands:**

```bash
tsc --noEmit
npx eslint --fix __tests__/app/contact/page.test.tsx
npx prettier --write __tests__/app/contact/page.test.tsx
npx vitest related run __tests__/app/contact/page.test.tsx
```

**Expected Result:** All tests pass.

### Step 18: Run Full Test Suite

**Command:**

```bash
npm test
```

**Why:** Ensure no regressions across entire codebase.

**Expected Result:** All tests pass with good coverage.

**Failure Handling:**

- If tests fail, debug and fix issues
- Re-run verification commands for affected files
- Maximum 3 attempts per failure; escalate to human if stuck

### Step 19: Manual Testing

**Test Scenarios:**

1. **Happy Path:**
    - Navigate to `/contact`
    - Verify Send Message button has white border (visible against black background)
    - Fill form with valid data
    - Submit form
    - Verify success message appears
    - Check `joe@yeoldeartoonist.com` inbox for email

2. **Validation:**
    - Submit form with invalid email
    - Verify validation error appears
    - Submit form with too-short message
    - Verify validation error appears

3. **Error Handling:**
    - Temporarily set invalid `RESEND_API_KEY` in `.env.local`
    - Submit form
    - Verify user sees success message (graceful degradation)
    - Check server logs for error
    - Restore valid API key

4. **Email Content:**
    - Submit form and check received email
    - Verify all fields present (name, email, message, timestamp)
    - Verify professional formatting
    - Verify no HTML/CSS issues

5. **Button Styling Regression:**
    - Check other pages using primary button variant
    - Verify no visual regressions

**Why:** Catch issues that automated tests might miss.

### Step 20: Build Verification

**Command:**

```bash
npm run build:full
```

**Why:** Ensure production build succeeds with all checks passing.

**Expected Result:** Build completes successfully.

**Failure Handling:**

- Fix any TypeScript, lint, or test errors
- Re-run verification commands for affected files

### Step 21: Update Environment Variable Documentation

**Files:**

- `.env.example` (already has `ADMIN_EMAIL`, verify it's correct)
- `.docs/SETUP.md` (if it mentions contact form as future work, update)

**Changes:**

- Confirm `ADMIN_EMAIL=joe@yeoldeartoonist.com` in `.env.example`
- Update any documentation mentioning contact form as "Phase 4" or future work

**Why:** Keep documentation in sync with implementation.

**Verification Commands:**

```bash
npx prettier --write .env.example
```

### Step 22: Request Human Review of All Local Changes

**Action:**

- Show summary of all changes made
- Highlight key files modified/created
- Request human to review locally and test manually

**Review Checklist:**

- Email template looks professional
- Button is clearly visible on contact page
- Form submission works end-to-end
- Error handling is graceful
- No regressions on other pages
- All tests pass
- Code quality is high

**Why:** Human validation before creating PR ensures quality.

### Step 23: Create Pull Request

**PR Title:**

```
feat: Add email functionality to contact form (#106)
```

**PR Description:**

```markdown
## Summary

- Implemented email sending for contact form submissions
- Contact form now sends to joe@yeoldeartoonist.com via Resend API
- Updated Send Message button styling for visibility (white border)
- Removed "Phase 4" implementation note from contact page

## Changes

### New Files

- `src/lib/email/templates/ContactFormSubmission.tsx` - Email template for contact submissions
- `src/app/api/contact/route.ts` - API endpoint for form submission
- `__tests__/lib/email/contact-template.test.tsx` - Tests for email template
- `__tests__/app/api/contact/route.test.ts` - Tests for API route

### Modified Files

- `src/lib/email/send.ts` - Added `sendContactFormEmail()` function
- `src/components/ui/Button.tsx` - Updated primary variant border color
- `src/app/contact/ContactClient.tsx` - Integrated API call, removed Phase 4 note
- `__tests__/lib/email/send.test.ts` - Added tests for new email function
- `__tests__/app/contact/page.test.tsx` - Updated tests for new behavior

## Test Plan

- [x] Unit tests for email template rendering
- [x] Unit tests for email sending function
- [x] Unit tests for API route
- [x] Integration tests for contact form
- [x] Manual testing of email delivery
- [x] Manual testing of button visibility
- [x] Visual regression testing for button on other pages
- [x] Error handling scenarios tested
- [x] Build verification (tsc, lint, format, test)

## Acceptance Criteria

- [x] AC #1: Form submissions send email to joe@yeoldeartoonist.com
- [x] AC #2: Send Message button has white border (#ffffff)
- [x] AC #3: Phase 4 implementation note removed

## Screenshots

[Include screenshot of contact page with visible Send Message button]
[Include screenshot of received email]

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
```

**Commands:**

```bash
git add .
git commit -m "$(cat <<'EOF'
feat: Add email functionality to contact form

- Add ContactFormSubmission email template
- Create /api/contact POST endpoint with validation
- Extend email service with sendContactFormEmail function
- Update Button primary variant for visibility on dark backgrounds
- Integrate contact form with API endpoint
- Add loading states and error handling
- Remove Phase 4 implementation note
- Add comprehensive tests for all new functionality

Closes #106

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
EOF
)"
git push -u origin issue-106

gh pr create --title "feat: Add email functionality to contact form (#106)" --body "$(cat <<'EOF'
## Summary
- Implemented email sending for contact form submissions
- Contact form now sends to joe@yeoldeartoonist.com via Resend API
- Updated Send Message button styling for visibility (white border)
- Removed "Phase 4" implementation note from contact page

## Changes
### New Files
- `src/lib/email/templates/ContactFormSubmission.tsx` - Email template
- `src/app/api/contact/route.ts` - API endpoint
- Tests for new functionality

### Modified Files
- `src/lib/email/send.ts` - Added `sendContactFormEmail()`
- `src/components/ui/Button.tsx` - Updated primary variant
- `src/app/contact/ContactClient.tsx` - API integration
- Updated existing tests

## Test Plan
- [x] All unit and integration tests pass
- [x] Manual email delivery verified
- [x] Button visibility confirmed
- [x] Error handling tested
- [x] Build verification passed

## Acceptance Criteria
- [x] AC #1: Form submissions send email to joe@yeoldeartoonist.com
- [x] AC #2: Send Message button has white border
- [x] AC #3: Phase 4 note removed

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
EOF
)"
```

**Why:** Clear PR for reviewer with all context and testing evidence.

### Step 24: After PR Approval, Squash and Merge

**Action:**

- Wait for PR approval from maintainer
- Address any review feedback
- Squash and merge PR via GitHub UI or CLI
- Delete branch after merge

**Command (if using CLI):**

```bash
gh pr merge --squash --delete-branch
```

**Why:** Clean git history with single commit per feature.

---

## Verification Process

After **EACH** implementation step (Steps 2-21), follow this verification procedure:

### Verification Commands

1. **TypeScript Compile Check:**

    ```bash
    tsc --noEmit
    ```

    - Verifies no TypeScript errors
    - Catches type mismatches, missing imports, etc.

2. **ESLint:**

    ```bash
    npx eslint --fix {files}
    ```

    - Replace `{files}` with space-separated paths of modified files
    - Fixes auto-fixable issues, reports others
    - Ensures code style compliance

3. **Prettier:**

    ```bash
    npx prettier --write {files}
    ```

    - Replace `{files}` with space-separated paths of modified files
    - Formats code consistently
    - Ensures formatting compliance

4. **Vitest Related Tests:**

    ```bash
    npx vitest related run {files}
    ```

    - Replace `{files}` with space-separated paths of modified files
    - Runs tests related to changed files
    - Faster than full test suite during development

### Verification Steps

1. Identify the specific file paths modified in the current step
2. Run verification commands in order, replacing `{files}` with actual paths
3. **If any command fails:**
    - Read error message carefully
    - Fix the specific error in the code
    - Re-run the failed verification command
    - If fixed, continue with remaining verification commands
4. **If failures persist beyond 3 attempts:**
    - STOP implementation
    - Document the issue (error message, attempted fixes, context)
    - Ask for human guidance
5. **Only proceed to next step when ALL verifications pass**

### Example

If modifying `src/lib/email/send.ts`:

```bash
# 1. TypeScript check (always run on whole project)
tsc --noEmit

# 2. Lint the specific file
npx eslint --fix src/lib/email/send.ts

# 3. Format the specific file
npx prettier --write src/lib/email/send.ts

# 4. Run related tests
npx vitest related run src/lib/email/send.ts
```

This ensures code quality and prevents accumulation of technical debt.

---

## Testing Strategy

### TDD Approach (Red-Green-Refactor)

Every implementation step follows TDD:

1. **Red Phase:** Write failing tests first
    - Define expected behavior via tests
    - Tests fail because implementation doesn't exist yet
    - Clarifies requirements before coding

2. **Green Phase:** Write minimal code to pass tests
    - Implement functionality to make tests pass
    - Focus on correctness, not optimization
    - Verify all tests pass

3. **Refactor Phase:** Improve code while maintaining passing tests
    - Extract duplicated logic
    - Improve naming and structure
    - Enhance readability
    - Verify tests still pass after changes

### Unit Tests

**Scope:** Individual functions and components in isolation

**Files:**

- `__tests__/lib/email/contact-template.test.tsx` (NEW)
- `__tests__/lib/email/send.test.ts` (MODIFY)
- `__tests__/app/api/contact/route.test.ts` (NEW)
- `__tests__/components/ui/Button.test.tsx` (MODIFY or NEW)

**Key Areas:**

- Email template rendering with various inputs
- Email sending function with success/error scenarios
- API route request/response handling
- Button component styling variants
- Form validation logic

**Coverage Goal:** >90% for all new code

### Integration Tests

**Scope:** Multiple components working together

**Files:**

- `__tests__/app/contact/page.test.tsx` (MODIFY)

**Key Scenarios:**

- Form submission â†’ API call â†’ success message
- Form validation â†’ error display â†’ retry
- API error â†’ graceful degradation â†’ fallback message
- Loading states during submission

**Coverage Goal:** All critical user flows covered

### Manual Testing Scenarios

**Scope:** End-to-end user experience and visual verification

**Test Cases:**

1. **Happy Path:** Submit valid form, receive email
2. **Validation:** Submit invalid data, see errors
3. **Error Handling:** Simulate API failure, verify graceful degradation
4. **Email Quality:** Verify email content, formatting, deliverability
5. **Button Visibility:** Check button on contact page (and other pages if changed globally)
6. **Accessibility:** Test with keyboard navigation, screen reader
7. **Responsive Design:** Test on mobile, tablet, desktop

**When to Execute:** After all automated tests pass (Step 19)

### Test Data Requirements and Setup

**Email Template Tests:**

- Valid contact data: name, email, message
- Edge cases: very long names, special characters in message, unusual email formats
- Missing optional fields (if any added in future)

**API Route Tests:**

- Mock Resend API responses (success, various errors)
- Mock environment variables (present, missing)
- Various request payloads (valid, invalid, malformed)

**Contact Form Tests:**

- Mock `fetch` API responses
- Mock setTimeout for success message timing

**Setup:**

- Use Vitest mocking utilities
- Create test fixtures for common scenarios
- Isolate tests with beforeEach/afterEach cleanup

### Test Coverage Goals

**Target:** >90% coverage for new code, maintain existing coverage

**Critical Paths:**

- Email sending function: 100% coverage
- API route: 100% coverage
- Form submission logic: 100% coverage
- Email template: >90% coverage

**How to Measure:**

```bash
npm test -- --coverage
```

Review coverage report, ensure all critical paths tested.

### Regression Tests for Existing Functionality

**Scope:** Ensure changes don't break existing features

**Key Areas:**

1. Contact form validation (existing behavior)
2. Button component usage on other pages
3. Email service for order confirmations (unaffected)
4. Other pages using primary button variant

**How to Verify:**

- Run full test suite: `npm test`
- Manual smoke testing of key pages
- Visual regression testing for button changes

---

## Considerations

### Security Implications

1. **Input Validation:**
    - Zod schema validates all user input
    - Prevents SQL injection (though not using SQL directly)
    - Prevents XSS (React escapes by default, React Email components handle escaping)
    - Message length limits prevent abuse

2. **Rate Limiting:**
    - Not implemented in this issue (out of scope)
    - Recommendation: Add in future (e.g., 5 submissions per IP per hour)
    - Could use middleware or API route rate limiting

3. **Email Injection:**
    - Resend API handles email header sanitization
    - Zod email validation prevents malformed addresses
    - No direct SMTP usage, so reduced risk

4. **API Key Security:**
    - `RESEND_API_KEY` stored in environment variables
    - Never exposed to client-side code
    - API route runs server-side only

5. **Spam Protection:**
    - Not implemented in this issue (out of scope)
    - Recommendation: Add honeypot field or CAPTCHA in future

### Performance Impacts

1. **Email Sending:**
    - Non-blocking for user (API returns immediately)
    - Resend API typically responds in <500ms
    - Error doesn't block user success message

2. **API Route Cold Starts:**
    - Serverless functions may have cold start latency
    - Mitigated by Next.js edge runtime optimization
    - Typically <1s even on cold start

3. **Email Template Rendering:**
    - React Email rendering is fast (<100ms)
    - Happens server-side, doesn't affect client

4. **Button Styling:**
    - CSS change has zero performance impact
    - No JavaScript changes to Button component

**Overall Impact:** Minimal; expected <1s additional latency for form submission

### Database Migrations

**None required** for this issue.

**Future Consideration:**

- Could store contact form submissions in database for admin review
- Out of scope for Issue #106

### Backward Compatibility

1. **Button Component:**
    - If changing primary variant globally: Audit all uses first (Step 11)
    - If creating new variant: No compatibility concerns
    - Recommendation: Create new variant to avoid risk

2. **Contact Form:**
    - Adding functionality, not changing existing behavior
    - Form still validates and shows success message as before
    - API call is new, but gracefully degrades on failure

3. **Email Service:**
    - New function added, existing functions unchanged
    - No breaking changes to `sendOrderConfirmationEmail` or `sendAdminNotificationEmail`

**Overall:** No backward compatibility concerns

### Documentation Updates Needed

1. **Environment Variables:**
    - Verify `.env.example` includes `ADMIN_EMAIL`
    - Update `.docs/SETUP.md` if it mentions contact form as future work

2. **API Documentation:**
    - Document `/api/contact` endpoint (if API docs exist)
    - Include request/response schema
    - Note rate limiting (if added in future)

3. **Email Templates:**
    - Add comment in `ContactFormSubmission.tsx` explaining purpose
    - Document any reusable styles extracted

4. **User-Facing:**
    - No user documentation needed (self-explanatory UI)
    - Consider adding FAQ about response time expectations

---

## Quality Checks

Before requesting human review, verify:

- âœ… All acceptance criteria from Issue #106 met
- âœ… All steps in implementation plan completed
- âœ… All tests passing (unit, integration, manual)
- âœ… Build verification passed (`npm run build:full`)
- âœ… TDD approach followed (Red-Green-Refactor) for each component
- âœ… SOLID principles applied and documented
- âœ… Verification commands run after each step
- âœ… No more than 3 verification attempts per failure (escalated if needed)
- âœ… Email template professionally designed and tested
- âœ… API route secure and validated
- âœ… Error handling graceful and user-friendly
- âœ… Button styling change doesn't break other pages
- âœ… Code quality high (TypeScript, ESLint, Prettier all pass)
- âœ… Test coverage >90% for new code
- âœ… Documentation updated
- âœ… PR description comprehensive with screenshots
- âœ… Commit message follows project conventions

---

## Next Steps

After human approval of this plan:

1. Implementer will execute each step sequentially
2. Implementer will update todo list to track progress
3. Implementer will run verification commands after each step
4. Implementer will escalate to human if stuck (max 3 attempts per issue)
5. Implementer will request human review before creating PR
6. Human will review PR and provide feedback
7. Implementer will address feedback and request re-review
8. Human will approve and merge PR

**Estimated Timeline:** This plan will be implemented step-by-step following TDD best practices. Each step includes verification to ensure quality.

---

## Appendix: File Paths Reference

### New Files to Create

```
src/lib/email/templates/ContactFormSubmission.tsx
src/app/api/contact/route.ts
__tests__/lib/email/contact-template.test.tsx
__tests__/app/api/contact/route.test.ts
__tests__/components/ui/Button.test.tsx (if doesn't exist)
```

### Files to Modify

```
src/lib/email/send.ts
src/components/ui/Button.tsx
src/app/contact/ContactClient.tsx
__tests__/lib/email/send.test.ts
__tests__/app/contact/page.test.tsx
.env.example (verify ADMIN_EMAIL)
.docs/SETUP.md (if applicable)
```

### Files to Reference (No Changes)

```
src/config/site.ts (for artist.email)
src/lib/email/templates/AdminNotification.tsx (for styling reference)
src/lib/email/templates/OrderConfirmation.tsx (for styling reference)
src/app/api/checkout/session/route.ts (for API route pattern reference)
```

---

**Plan Status:** âœ… APPROVED - Ready for Implementation

**Next Action:** Begin implementation following the steps outlined in this plan
