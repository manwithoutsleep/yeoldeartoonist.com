# Phase 3: Admin System Implementation

**Date:** 2025-11-06
**Status:** Planning
**Parent Spec:** [MVP Implementation Plan](./2025-10-25T17-55-00-mvp-implementation-plan.md)

---

## Overview

Phase 3 focuses on building a complete admin system for managing site content, orders, and media. This includes authentication (already implemented), a dashboard, content management for artwork/projects/events, order management, and image upload capabilities.

### Relationship to Full MVP Plan

This specification extracts and expands Phase 3 from the [MVP Implementation Plan](./2025-10-25T17-55-00-mvp-implementation-plan.md). It integrates testing requirements directly into implementation steps, following Test-Driven Development (TDD) principles.

### Development Approach: Test-Driven Development (TDD)

**All Phase 3 features will be developed using the Red/Green/Refactor pattern:**

1. **Red**: Write a failing test that describes the desired behavior
2. **Green**: Write minimal code to make the test pass
3. **Refactor**: Improve code quality while keeping tests green

**Critical Rule**: No feature implementation without a failing test first. Where existing testing gaps are discovered, add tests for those features before proceeding.

### Prerequisites (Completed in Earlier Phases)

- ✅ Phase 1: Database schema with `artwork`, `orders`, `projects`, `events`, `administrators` tables
- ✅ Phase 2: Public pages (gallery, shoppe, contact, in-the-works)
- ✅ Phase 2.5: Testing infrastructure (Jest, React Testing Library)
- ✅ Admin authentication and proxy with 15-minute session caching
- ✅ Admin login page with comprehensive tests

### Prerequisites (Must Be Configured Before Starting Phase 3)

#### Supabase Storage Setup ✅ Complete

Before beginning Phase 3 implementation, configure Supabase Storage for image uploads:

1. **Create Storage Bucket**: ✅ Complete
    - Log in to Supabase dashboard
    - Navigate to Storage section
    - Click "New bucket"
    - Bucket name: `artwork`
    - Set to **Public** bucket (images need public URLs)
    - Click "Create bucket"

2. **Configure Bucket Policies**: ✅ Complete

    ```sql
    -- Allow public read access to artwork images
    CREATE POLICY "Public Access"
    ON storage.objects FOR SELECT
    USING (bucket_id = 'artwork');

    -- Allow authenticated admins to upload
    CREATE POLICY "Admin Upload"
    ON storage.objects FOR INSERT
    TO authenticated
    WITH CHECK (bucket_id = 'artwork');

    -- Allow authenticated admins to delete
    CREATE POLICY "Admin Delete"
    ON storage.objects FOR DELETE
    TO authenticated
    USING (bucket_id = 'artwork');
    ```

3. **Configure File Size Limits**: ✅ Complete
    - In bucket settings, set maximum file size: 10MB
    - This prevents excessively large uploads

4. **Verify Setup**: ✅ Complete
    - Upload a test image via Supabase dashboard
    - Get public URL using "Get URL" button
    - Verify URL is accessible in browser

#### Update Proxy to Include Admin Name ✅ Complete

The proxy (formerly middleware) currently stores `userId`, `adminId`, `role`, and `expiresAt` in the session cookie, but the admin header needs to display the admin's name. Update the proxy:

**File**: `src/proxy.ts`

**Change** (around line 80-90):

```typescript
// BEFORE:
const sessionCache = JSON.stringify({
    userId: user.id,
    adminId: admin.id,
    role: admin.role,
    expiresAt: cacheExpiry,
});

// AFTER:
const sessionCache = JSON.stringify({
    userId: user.id,
    adminId: admin.id,
    name: admin.name, // ADD THIS LINE
    role: admin.role,
    expiresAt: cacheExpiry,
});
```

**Rationale**: The admin header component needs to display the admin's name without making additional database queries. Including it in the cached session cookie provides this data efficiently.

#### Install Form Management Dependencies ✅ Complete

Phase 3 uses React Hook Form with Zod validation for all admin forms:

```bash
npm install react-hook-form @hookform/resolvers/zod
```

**Why React Hook Form**:

- Industry standard for React forms
- Excellent TypeScript support
- Built-in Zod integration via `@hookform/resolvers`
- Minimal re-renders (performance)
- Simple error handling

---

## Goals

Build a complete admin dashboard for:

1. **Content Management**: CRUD operations for artwork, projects, events, pages
2. **Order Management**: View orders, update status, track shipments
3. **Image Upload**: Upload and optimize images with variants (thumbnail, preview, large)
4. **Role-Based Access**: Distinguish between `admin` and `super_admin` roles
5. **Cache Revalidation**: Clear Next.js cache when content changes

---

## Current State Analysis

### Existing Admin Infrastructure

**Authentication (Already Implemented)**:

- Admin login page at `/admin/login` (client component with form validation)
- proxy protection for `/admin/*` routes (except `/admin/login`)
- Session caching via `admin_session` cookie (15-minute TTL)
- Cookie stores: `userId`, `adminId`, `role`, `expiresAt`
- Session validation checks user in `administrators` table with `is_active = true`
- Redirects to `/admin/login` if authentication fails

**Database Query Patterns**:
All existing query functions (`src/lib/db/artwork.ts`, `events.ts`, `projects.ts`, `pages.ts`) follow this pattern:

```typescript
export async function queryName(params): Promise<{
    data: T | null;
    error: ErrorType | null;
}>;
```

**Key characteristics**:

- Never throw exceptions - always return `{ data, error }` tuple
- Custom error interfaces per module (e.g., `ArtworkQueryError`)
- Error structure: `{ code: string, message: string, details?: string }`
- Use browser client with anon key for public queries
- Filter by `is_published: true` for public data
- Support pagination via `limit` and `offset` parameters
- Development-only error details in `details` field

**Component Patterns**:

- TypeScript interfaces for all props (exported)
- Extends HTML attributes for native elements
- Variants and sizes via props (e.g., Button: `variant: 'primary' | 'secondary' | 'outline'`)
- Tailwind CSS utility classes for styling
- Compound components (e.g., Card with CardHeader/CardBody/CardFooter)
- Children prop for composition

**Supabase Client Strategy**:

- **Browser client** (`src/lib/supabase/client.ts`): Uses public anon key for public queries and auth
- **Server client** (`src/lib/supabase/server.ts`): Uses service role key for admin operations and RLS bypass

**Testing Infrastructure**:

- Jest 30.2.0 with React Testing Library 16.3.0
- Coverage thresholds: 80-85% for components, 100% for critical modules
- Mock Supabase client in tests
- Comprehensive test patterns established (see login page: 1520 lines of tests)

**Path Aliases**:

- TypeScript and Jest configured with: `@/`, `@/app/`, `@/components/`, `@/lib/`, `@/types/`, `@/hooks/`, `@/context/`

### What Needs to Be Built

**Admin Routes**:

- `/admin` - Dashboard (currently placeholder)
- `/admin/artwork` - Artwork management
- `/admin/artwork/new` - Create artwork
- `/admin/artwork/[id]/edit` - Edit artwork
- `/admin/orders` - Orders list
- `/admin/orders/[id]` - Order detail
- `/admin/projects` - Projects management
- `/admin/events` - Events management
- `/admin/settings` - Settings (super_admin only)

**Admin Components** (`src/components/admin/` - currently empty):

- AdminHeader - Compact header with logo, user name, logout button
- AdminNavigation - Responsive navigation (menu bar on desktop, sidebar on mobile)
- AdminCard, AdminTable, AdminForm - Layout primitives
- ArtworkForm, ProjectForm, EventForm - Content forms
- OrdersList, OrderDetail - Order management
- ImageUploader - File upload with preview

**Admin Database Functions** (`src/lib/db/admin/` - to be created):

- Admin CRUD for artwork, projects, events, pages
- Order queries and status updates
- Admin user management (super_admin only)

**API Routes** (`src/app/api/admin/` - to be created):

- `/api/admin/upload` - Image upload endpoint
- `/api/admin/revalidate` - Cache revalidation
- Potential CRUD endpoints if needed

---

## Architecture Decisions

### 1. Admin Query Functions Use Server Client (Service Role Key)

**Decision**: Admin operations will use the Supabase service role key to bypass RLS policies, rather than extending RLS policies to handle admin access.

**Reasoning**:

This project uses **service role key approach** for admin operations for these reasons:

1. **Simpler RLS policies**: Public RLS policies remain focused on public access only (`is_published = true` filters). No need to handle admin role checks in every RLS policy.

2. **Centralized authorization**: All admin authorization happens in one place (proxy), not scattered across multiple RLS policies per table. Easier to audit and maintain.

3. **Development velocity**: MVP phase prioritizes speed. Simple RLS policies = faster development. Complex role-based RLS can be added later if needed.

4. **Performance**: No RLS policy evaluation overhead on admin operations. Important for content updates and bulk operations.

5. **Flexibility**: Can perform operations that don't fit RLS model (cross-table queries, bulk updates, admin-specific logic).

6. **Clear separation**: Public queries use anon key (`src/lib/supabase/client.ts`), admin queries use service role (`src/lib/supabase/server.ts`). Easy to audit which code paths have elevated privileges.

**Security Safeguards**:

While the service role key has full database access, we mitigate risks with these safeguards:

1. **Environment variable protection**:
    - Service role key stored in `.env.local` (gitignored)
    - Vercel uses encrypted environment variables in production
    - Never exposed to client-side code

2. **proxy protection**: All admin routes protected by proxy that validates admin session before allowing access

3. **API route protection**: All admin mutations go through `/api/admin/*` routes that verify session. Even if service key leaked, attacker needs valid admin session cookie.

4. **Server-side only enforcement**: Admin query functions include runtime checks to ensure they're only called server-side:

    ```typescript
    if (typeof window !== 'undefined') {
        throw new Error('Admin queries must run server-side only');
    }
    ```

5. **Application-level logging**: All admin operations logged in application code for audit trail

6. **Defense in depth**: proxy + API route checks + server-side enforcement = multiple layers of protection

**Alternative Considered**: Extending RLS policies to handle admin roles was considered but rejected due to:

- Complexity: Every table would need admin role checks in RLS policies
- Performance: RLS evaluation overhead on every admin query (JOIN to `administrators` table)
- Debugging difficulty: RLS policy bugs are notoriously hard to troubleshoot
- Maintenance burden: Every new table needs admin policies (easy to forget)

**Future Migration Path**: If more granular permissions are needed (e.g., "editor" role that can update but not delete), RLS-based admin access can be added without changing public-facing code. The service role approach provides velocity now with acceptable risk given our safeguards.

**Implementation Pattern**:

All admin query functions in `src/lib/db/admin/` will:

- Import from `@/lib/supabase/server` (service role key)
- Follow the same `{ data, error }` return pattern as public queries
- Include proper error handling and development-only error details
- Include runtime checks to ensure server-side execution only

### 2. Admin Components in Feature Folder

Admin UI components will be organized in `src/components/admin/`:

- Follow existing UI component patterns (variants, sizes, props)
- Extend UI primitives (Button, Card, Input) where possible
- Create admin-specific primitives (AdminTable, AdminForm) as needed

### 3. Admin Layout for Consistent Navigation

**Decision**: Admin pages will have a dedicated layout that replaces the public navigation with an admin-specific navigation system.

**Design Approach**:

The admin layout uses a **responsive navigation strategy**:

- **Desktop/Full-size screens**: Horizontal menu bar below a compact header
- **Tablet/Mobile screens**: Collapsible sidebar navigation (hamburger menu)

**Admin Header** (`src/components/admin/AdminHeader.tsx`):

- **Compact design**: Smaller than public header to maximize content area
- **Logo**: Small version of site logo in top-left corner (links to `/admin` dashboard)
- **User info**: Current admin name displayed in header
- **Logout button**: Prominent logout button in top-right corner
- **Responsive**: On mobile, includes hamburger menu button to toggle sidebar

**Admin Navigation** (`src/components/admin/AdminNavigation.tsx`):

- **Desktop** (≥1024px): Horizontal menu bar with links:
    - Dashboard | Artwork | Orders | Projects | Events | Settings (super_admin only)
    - Active route highlighted with underline or background color
    - Clean, professional styling with adequate spacing

- **Mobile/Tablet** (<1024px): Sidebar navigation:
    - Slides in from left when hamburger menu clicked
    - Overlay backdrop when open (click to close)
    - Same links as desktop, stacked vertically
    - Close button or swipe gesture to dismiss
    - Active route highlighted

**Role-Based Visibility**:

- Settings link only visible to `super_admin` role
- Role determined from `admin_session` cookie
- Client-side check for UI visibility (proxy enforces server-side)

**Layout Structure** (`src/app/admin/layout.tsx`):

```tsx
<div className="admin-layout">
    <AdminHeader /> {/* Logo, user name, logout */}
    <AdminNavigation /> {/* Menu bar (desktop) or sidebar trigger (mobile) */}
    <main className="admin-content">
        {children} {/* Admin page content */}
    </main>
</div>
```

**Styling Considerations**:

- Use Tailwind's responsive breakpoints (`lg:`, `md:`, `sm:`)
- Admin header height: ~60px (vs. ~120px for public header)
- Menu bar height: ~48px on desktop
- Sidebar width: 256px on mobile/tablet when open
- Maintain black/white theme consistent with public site
- Ensure sufficient contrast for accessibility

**Benefits of This Approach**:

1. **Maximizes content area**: Compact header and horizontal menu on desktop
2. **Familiar UX**: Menu bar pattern common in admin dashboards
3. **Mobile-friendly**: Sidebar saves vertical space on small screens
4. **Clean separation**: Admin navigation completely separate from public navigation
5. **Easy to extend**: Add new menu items without cluttering UI

### 4. Image Upload Strategy

Images will be uploaded to Supabase Storage with three variants:

- **Thumbnail** (300px): Grid views
- **Preview** (800px): Detail pages
- **Large** (1600px): Full-size viewing

Upload process:

1. Client uploads to `/api/admin/upload` endpoint
2. Server uses Sharp to generate variants and convert to WebP
3. Upload all variants to Supabase Storage `artwork` bucket
4. Return URLs to client for database storage

### 5. Cache Revalidation on Content Changes

When content is created/updated/deleted:

- Call `/api/admin/revalidate` endpoint
- Use Next.js `revalidatePath()` to clear relevant page caches
- Ensure public pages reflect changes immediately

### 6. Role-Based Access Control

Two roles in `administrators` table:

- **admin**: Can manage content and orders
- **super_admin**: Can also manage admin users and settings

proxy stores `role` in session cookie for client-side checks.

### 7. Server Actions for Form Submissions

**Decision**: All admin form submissions use Next.js Server Actions, not API routes.

**Pattern**:

Admin query functions (`src/lib/db/admin/*.ts`) use the service role client and must run server-side only. To call these from client components (forms), use Server Actions:

```typescript
// src/app/admin/artwork/actions.ts
'use server';

import { createArtwork } from '@/lib/db/admin/artwork';
import { revalidatePath } from 'next/cache';
import type { ArtworkInput } from '@/lib/validation/artwork';

export async function createArtworkAction(data: ArtworkInput) {
    const result = await createArtwork(data);

    if (result.data) {
        // Revalidate public pages after successful creation
        revalidatePath('/gallery');
        revalidatePath('/shoppe');
    }

    return result;
}
```

**Usage in Client Component**:

```typescript
// src/app/admin/artwork/new/page.tsx
'use client'

import { createArtworkAction } from './actions';

export default function NewArtworkPage() {
    const onSubmit = async (data: ArtworkInput) => {
        const { data: artwork, error } = await createArtworkAction(data);
        if (error) {
            alert(`Error: ${error.message}`);
        } else {
            alert('Artwork created successfully!');
            router.push('/admin/artwork');
        }
    };

    return <ArtworkForm onSubmit={onSubmit} />;
}
```

**Why Server Actions**:

- Secure: Server Actions run server-side with service role key
- Simple: No need to create separate API routes
- Type-safe: Full TypeScript support across client/server boundary
- Built-in: Next.js 14 feature, no additional libraries
- Co-located: Actions file lives next to page that uses it

**API Routes vs Server Actions**:

- **Use Server Actions**: For form mutations (create, update, delete)
- **Use API Routes**: For file uploads (`/api/admin/upload`), webhooks, or when non-Next.js clients need access

### 8. Authentication Patterns

**Critical**: proxy protects `/admin/*` page routes but **does NOT protect `/api/admin/*` API routes**. All API routes must manually verify authentication.

**API Route Authentication Pattern**:

```typescript
// src/app/api/admin/upload/route.ts
import { cookies } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
    // Verify admin session
    const cookieStore = await cookies();
    const sessionCookie = cookieStore.get('admin_session');

    if (!sessionCookie) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    try {
        const session = JSON.parse(sessionCookie.value);

        // Check session expiry
        if (
            !session.userId ||
            !session.expiresAt ||
            session.expiresAt < Date.now()
        ) {
            return NextResponse.json(
                { error: 'Session expired' },
                { status: 401 }
            );
        }

        // Proceed with authenticated logic
        // ...
    } catch (error) {
        return NextResponse.json({ error: 'Invalid session' }, { status: 401 });
    }
}
```

**Server Component Authentication (e.g., Settings Page)**:

```typescript
// src/app/admin/settings/page.tsx
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';

export default async function SettingsPage() {
    const cookieStore = await cookies();
    const sessionCookie = cookieStore.get('admin_session');

    if (!sessionCookie) {
        redirect('/admin/login');
    }

    const session = JSON.parse(sessionCookie.value);

    // Check super_admin role
    if (session.role !== 'super_admin') {
        return (
            <div className="p-8">
                <h1 className="text-2xl font-bold mb-4">Access Denied</h1>
                <p>You must be a super admin to access this page.</p>
            </div>
        );
    }

    // Render settings page
    return <SettingsContent adminName={session.name} />;
}
```

**Client Component Cookie Reading**:

For UI-only decisions (e.g., showing/hiding Settings link), read cookie client-side:

```typescript
// src/lib/utils/session.ts
export function getAdminSessionFromClient(): {
    userId: string;
    adminId: string;
    name: string;
    role: 'admin' | 'super_admin';
    expiresAt: number;
} | null {
    if (typeof window === 'undefined') return null;

    const cookie = document.cookie
        .split('; ')
        .find((row) => row.startsWith('admin_session='));

    if (!cookie) return null;

    try {
        const value = decodeURIComponent(cookie.split('=')[1]);
        return JSON.parse(value);
    } catch {
        return null;
    }
}
```

**Security Note**: Client-side cookie checks are for UI convenience only. Always verify authorization server-side (proxy, Server Actions, or API routes).

### 9. Image Field Naming Convention

**Database Fields** (from `artwork` table schema):

- `image_thumbnail_url` - Thumbnail variant (300px)
- `image_url` - Preview variant (800px) - **primary display image**
- `image_large_url` - Large variant (1600px)

**ImageUploader Component Returns**:

```typescript
{
    image_thumbnail_url: string; // 300px variant
    image_url: string; // 800px variant (preview)
    image_large_url: string; // 1600px variant
}
```

**Consistent Naming**: Always use database field names throughout the application. The "preview" size is stored in the `image_url` field.

---

## Testing Strategy

### Coverage Goals

- **Admin components**: 80-85% coverage (matching existing component standards)
- **Admin query functions**: 100% coverage (critical business logic)
- **Admin pages**: 70%+ coverage (integration tests)
- **API routes**: 90%+ coverage (security-critical)

### Test Patterns

**Component Tests** (follow existing patterns):

```typescript
describe('ComponentName', () => {
    it('renders without crashing', () => {
        /* ... */
    });
    it('displays correct props', () => {
        /* ... */
    });
    it('handles user interactions', () => {
        /* ... */
    });
    it('shows error states', () => {
        /* ... */
    });
    it('has accessible labels', () => {
        /* ... */
    });
});
```

**Query Function Tests** (mock Supabase):

```typescript
describe('adminQueryFunction', () => {
    it('returns data on success', async () => {
        /* ... */
    });
    it('returns error on failure', async () => {
        /* ... */
    });
    it('handles edge cases', async () => {
        /* ... */
    });
    it('uses service role client', async () => {
        /* ... */
    });
});
```

**Integration Tests** (full flows):

```typescript
describe('Admin Dashboard Flow', () => {
    it('loads dashboard with metrics', async () => {
        /* ... */
    });
    it('navigates to artwork management', async () => {
        /* ... */
    });
    it('creates new artwork', async () => {
        /* ... */
    });
});
```

### TDD Workflow Example

**Creating a new admin feature**:

1. **Write failing test**:

    ```typescript
    it('creates new artwork with valid data', async () => {
        const result = await createArtwork(validArtworkData);
        expect(result.data).toBeDefined();
        expect(result.error).toBeNull();
    });
    ```

2. **Run test - it should fail** (Red):

    ```bash
    npm test -- src/lib/db/admin/artwork.test.ts
    ```

3. **Implement minimal code** (Green):

    ```typescript
    export async function createArtwork(data: ArtworkInput) {
        const supabase = createServerClient();
        const { data: artwork, error } = await supabase
            .from('artwork')
            .insert(data)
            .select()
            .single();

        if (error)
            return {
                data: null,
                error: { code: error.code, message: error.message },
            };
        return { data: artwork, error: null };
    }
    ```

4. **Run test - it should pass** (Green):

    ```bash
    npm test -- src/lib/db/admin/artwork.test.ts
    ```

5. **Refactor** (Refactor):
    - Add error handling for edge cases
    - Add validation
    - Improve type safety
    - Re-run tests to ensure they still pass

---

## Implementation Tasks

### Phase 3.1: Admin Dashboard & Metrics

**Goal**: Build main dashboard with key metrics and navigation.

#### 3.1.1: Write Tests for Dashboard Metrics Query

**TDD Step: Red**

- [ ] Create `__tests__/lib/db/admin/dashboard.test.ts`
- [ ] Write failing tests for `getDashboardMetrics()`:
    - [ ] Test returns total orders count
    - [ ] Test returns orders this month count
    - [ ] Test returns total revenue
    - [ ] Test returns pending orders count
    - [ ] Test uses service role client
    - [ ] Test handles database errors gracefully
    - [ ] Test returns { data, error } format

**Expected Test Output**: All tests fail (function doesn't exist yet)

#### 3.1.2: Implement Dashboard Metrics Query

**TDD Step: Green**

- [ ] Create `src/lib/db/admin/dashboard.ts`
- [ ] Implement `getDashboardMetrics()`:
    - [ ] Query orders table for counts and sums
    - [ ] Use server client (service role key)
    - [ ] Follow { data, error } return pattern
    - [ ] Calculate metrics:
        - [ ] Total orders: COUNT(\*)
        - [ ] Orders this month: COUNT(\*) WHERE created_at >= start of month
        - [ ] Total revenue: SUM(total_amount)
        - [ ] Pending orders: COUNT(\*) WHERE status = 'pending'
    - [ ] Handle errors with proper error interface
- [ ] Run tests - should now pass

#### 3.1.3: Write Tests for Recent Orders Query

**TDD Step: Red**

- [ ] Add tests to `__tests__/lib/db/admin/dashboard.test.ts` for `getRecentOrders()`:
    - [ ] Test returns last 10 orders
    - [ ] Test orders sorted by created_at DESC
    - [ ] Test includes customer name and email
    - [ ] Test includes order total and status
    - [ ] Test pagination works (limit parameter)
    - [ ] Test error handling

#### 3.1.4: Implement Recent Orders Query

**TDD Step: Green**

- [ ] Add `getRecentOrders()` to `src/lib/db/admin/dashboard.ts`:
    - [ ] Query orders table with limit (default 10)
    - [ ] Sort by created_at DESC
    - [ ] Select relevant fields (order_number, customer_name, total_amount, status, created_at)
    - [ ] Return { data, error } format
- [ ] Run tests - should pass

#### 3.1.5: Write Tests for AdminCard Component

**TDD Step: Red**

- [ ] Create `__tests__/components/admin/AdminCard.test.tsx`
- [ ] Write tests:
    - [ ] Renders title prop
    - [ ] Renders children content
    - [ ] Applies custom className
    - [ ] Shows loading state (optional skeleton)
    - [ ] Renders metric value with label
    - [ ] Accessible (proper heading hierarchy)

#### 3.1.6: Implement AdminCard Component

**TDD Step: Green**

- [ ] Create `src/components/admin/AdminCard.tsx`
- [ ] Extend existing Card component pattern
- [ ] Props:
    - [ ] `title: string`
    - [ ] `value?: string | number` (for metrics)
    - [ ] `label?: string` (for metric description)
    - [ ] `loading?: boolean`
    - [ ] `children?: React.ReactNode`
    - [ ] `className?: string`
- [ ] Style with Tailwind CSS
- [ ] Run tests - should pass

#### 3.1.7: Write Tests for AdminHeader Component

**TDD Step: Red**

- [ ] Create `__tests__/components/admin/AdminHeader.test.tsx`
- [ ] Write tests:
    - [ ] Renders small logo in top-left
    - [ ] Logo links to `/admin` dashboard
    - [ ] Displays current admin name
    - [ ] Renders logout button
    - [ ] Logout button calls signOut()
    - [ ] Compact height (~60px)
    - [ ] On mobile: renders hamburger menu button
    - [ ] Hamburger button toggles navigation state

#### 3.1.8: Implement AdminHeader Component

**TDD Step: Green**

- [ ] Create `src/components/admin/AdminHeader.tsx`
- [ ] Client component (needs state for mobile menu, useAuth for logout)
- [ ] Props:
    - [ ] `adminName: string`
    - [ ] `onMenuToggle?: () => void` (for mobile sidebar toggle)
- [ ] Layout structure:
    - [ ] Container with ~60px height
    - [ ] Left: Small logo (link to `/admin`)
    - [ ] Center: Admin name display (visible on desktop, hidden on mobile)
    - [ ] Right: Logout button
    - [ ] Mobile: Hamburger menu button (left side, before logo)
- [ ] Use existing Button component for logout
- [ ] Style with Tailwind (black/white theme)
- [ ] Run tests - should pass

#### 3.1.9: Write Tests for AdminNavigation Component

**TDD Step: Red**

- [ ] Create `__tests__/components/admin/AdminNavigation.test.tsx`
- [ ] Write tests:
    - [ ] Desktop (≥1024px): Renders horizontal menu bar
    - [ ] Desktop: Shows all navigation links (Dashboard, Artwork, Orders, Projects, Events)
    - [ ] Desktop: Shows Settings link only for super_admin role
    - [ ] Desktop: Highlights active route
    - [ ] Mobile (<1024px): Renders as sidebar
    - [ ] Mobile: Sidebar hidden by default (isOpen = false)
    - [ ] Mobile: Sidebar visible when isOpen = true
    - [ ] Mobile: Overlay backdrop present when open
    - [ ] Mobile: Clicking backdrop closes sidebar
    - [ ] Mobile: Navigation links stacked vertically
    - [ ] All screen sizes: Links navigate to correct routes

#### 3.1.10: Implement AdminNavigation Component

**TDD Step: Green**

- [ ] Create `src/components/admin/AdminNavigation.tsx`
- [ ] Client component (needs usePathname for active route)
- [ ] Props:
    - [ ] `role: 'admin' | 'super_admin'`
    - [ ] `isOpen: boolean` (for mobile sidebar state)
    - [ ] `onClose: () => void` (callback to close mobile sidebar)
- [ ] Navigation links array:
    ```typescript
    const links = [
        { label: 'Dashboard', href: '/admin' },
        { label: 'Artwork', href: '/admin/artwork' },
        { label: 'Orders', href: '/admin/orders' },
        { label: 'Projects', href: '/admin/projects' },
        { label: 'Events', href: '/admin/events' },
        {
            label: 'Settings',
            href: '/admin/settings',
            requiresSuperAdmin: true,
        },
    ];
    ```
- [ ] Desktop rendering (Tailwind `hidden lg:flex`):
    - [ ] Horizontal flex container (~48px height)
    - [ ] Links with padding and hover states
    - [ ] Active link with underline or background
    - [ ] Filter out Settings if role !== 'super_admin'
- [ ] Mobile rendering (Tailwind `lg:hidden`):
    - [ ] Sidebar container (256px width, fixed position)
    - [ ] Slide-in animation (translate-x-0 when open)
    - [ ] Backdrop overlay (click to close)
    - [ ] Vertical stacked links
    - [ ] Close button or swipe gesture
- [ ] Run tests - should pass

#### 3.1.11: Write Tests for Admin Layout

**TDD Step: Red**

- [ ] Create `__tests__/app/admin/layout.test.tsx`
- [ ] Write tests:
    - [ ] Renders AdminHeader
    - [ ] Renders AdminNavigation
    - [ ] Renders children content
    - [ ] Has proper semantic structure (header, nav, main)
    - [ ] Passes admin name to header
    - [ ] Passes role to navigation
    - [ ] Mobile menu toggle state works

#### 3.1.12: Implement Admin Layout

**TDD Step: Green**

- [ ] Create `src/app/admin/layout.tsx`
- [ ] Client component (needs state for mobile menu)
- [ ] Read admin name and role from admin_session cookie
- [ ] State: `const [mobileMenuOpen, setMobileMenuOpen] = useState(false)`
- [ ] Structure:
    ```tsx
    <div className="admin-layout">
        <AdminHeader
            adminName={adminName}
            onMenuToggle={() => setMobileMenuOpen(!mobileMenuOpen)}
        />
        <AdminNavigation
            role={role}
            isOpen={mobileMenuOpen}
            onClose={() => setMobileMenuOpen(false)}
        />
        <main className="admin-content">{children}</main>
    </div>
    ```
- [ ] Responsive layout with Tailwind
- [ ] Run tests - should pass

#### 3.1.13: Write Tests for Dashboard Page

**TDD Step: Red**

- [ ] Create `__tests__/app/admin/dashboard.test.tsx`
- [ ] Write tests:
    - [ ] Renders dashboard title
    - [ ] Displays all metric cards (4 metrics)
    - [ ] Shows recent orders list
    - [ ] Handles loading state
    - [ ] Handles error state (metrics query fails)
    - [ ] Displays order details (number, customer, total, status)
    - [ ] Links to order detail pages

#### 3.1.14: Implement Dashboard Page

**TDD Step: Green**

- [ ] Update `src/app/admin/page.tsx` (currently placeholder)
- [ ] Server component
- [ ] Fetch dashboard metrics using `getDashboardMetrics()`
- [ ] Fetch recent orders using `getRecentOrders()`
- [ ] Handle errors gracefully (show error message)
- [ ] Layout:
    - [ ] Page title: "Dashboard"
    - [ ] Metrics grid (4 AdminCard components):
        - [ ] Total Orders
        - [ ] Orders This Month
        - [ ] Total Revenue
        - [ ] Pending Orders
    - [ ] Recent orders section:
        - [ ] Table with columns: Order Number, Customer, Total, Status, Date
        - [ ] Link to order detail page
        - [ ] Empty state message if no orders
- [ ] Run tests - should pass

#### 3.1.15: Refactor and Verify

**TDD Step: Refactor**

- [ ] Review all code for quality:
    - [ ] Remove duplication
    - [ ] Improve naming
    - [ ] Add JSDoc comments
    - [ ] Ensure proper error boundaries
- [ ] Run full test suite: `npm test`
- [ ] Verify coverage: `npm run test:coverage`
- [ ] Manual testing:
    - [ ] Navigate to `/admin`
    - [ ] Verify metrics display (may be 0 if no orders)
    - [ ] Desktop: Verify horizontal menu bar displays below header
    - [ ] Desktop: Click each navigation link (Dashboard, Artwork, Orders, etc.)
    - [ ] Desktop: Verify active route is highlighted
    - [ ] Mobile: Verify hamburger menu button appears
    - [ ] Mobile: Click hamburger to open sidebar
    - [ ] Mobile: Verify sidebar slides in from left
    - [ ] Mobile: Click backdrop to close sidebar
    - [ ] Mobile: Verify navigation links work in sidebar
    - [ ] Test logout functionality
    - [ ] Verify logo links to dashboard
- [ ] Lint and format: `npm run lint && npm run format`

---

### Phase 3.2: Artwork Management

**Goal**: Build CRUD interface for managing artwork (gallery and shop items).

#### 3.2.1: Write Tests for Admin Artwork Queries

**TDD Step: Red**

- [ ] Create `__tests__/lib/db/admin/artwork.test.ts`
- [ ] Write failing tests for:
    - [ ] `getAllArtworkAdmin()` - returns ALL artwork (not just published)
    - [ ] `getArtworkById(id)` - returns single artwork by UUID
    - [ ] `createArtwork(data)` - inserts new artwork
    - [ ] `updateArtwork(id, data)` - updates existing artwork
    - [ ] `deleteArtwork(id)` - deletes artwork
    - [ ] Test all functions use server client
    - [ ] Test { data, error } return pattern
    - [ ] Test error handling (missing ID, invalid data, DB errors)

#### 3.2.2: Implement Admin Artwork Queries

**TDD Step: Green**

- [ ] Create `src/lib/db/admin/artwork.ts`
- [ ] Implement all query functions:
    - [ ] `getAllArtworkAdmin(limit?, offset?)` - no is_published filter
    - [ ] `getArtworkById(id: string)` - single select by UUID
    - [ ] `createArtwork(data: ArtworkInput)` - insert with validation
    - [ ] `updateArtwork(id: string, data: Partial<ArtworkInput>)` - update
    - [ ] `deleteArtwork(id: string)` - delete by UUID
- [ ] Use server client (service role)
- [ ] Define `ArtworkInput` type (extend database type)
- [ ] Define `ArtworkAdminError` interface
- [ ] Run tests - should pass

#### 3.2.3: Write Tests for ArtworkForm Component

**TDD Step: Red**

- [ ] Create `__tests__/components/admin/ArtworkForm.test.tsx`
- [ ] Write tests:
    - [ ] Renders all form fields (title, description, slug, price, etc.)
    - [ ] Validates required fields (title, slug)
    - [ ] Shows validation errors
    - [ ] Submit button disabled when invalid
    - [ ] Calls onSubmit with form data
    - [ ] Pre-fills form in edit mode
    - [ ] Image upload integration (ImageUploader component)
    - [ ] Shows loading state during submission
    - [ ] Shows success/error messages

#### 3.2.4: Create Artwork Form Validation Schema

**TDD Step: Green (Preparation)**

- [ ] Create `src/lib/validation/artwork.ts`
- [ ] Define Zod schema for artwork:
    ```typescript
    export const artworkSchema = z.object({
        title: z.string().min(1, 'Title is required'),
        slug: z
            .string()
            .min(1, 'Slug is required')
            .regex(/^[a-z0-9-]+$/, 'Invalid slug format'),
        description: z.string().optional(),
        price: z.number().min(0).optional(),
        original_price: z.number().min(0).optional(),
        sku: z.string().optional(),
        inventory_count: z.number().int().min(0).default(0),
        is_limited_edition: z.boolean().default(false),
        medium: z.string().optional(),
        dimensions: z.string().optional(),
        year_created: z.number().int().optional(),
        is_published: z.boolean().default(false),
        is_featured: z.boolean().default(false),
        display_order: z.number().int().default(0),
        image_url: z.string().url().optional(),
        thumbnail_url: z.string().url().optional(),
        alt_text: z.string().optional(),
        seo_title: z.string().optional(),
        seo_description: z.string().optional(),
        tags: z.array(z.string()).optional(),
    });
    ```
- [ ] Export `ArtworkFormData` type from schema

#### 3.2.5: Implement ArtworkForm Component

**TDD Step: Green**

- [ ] Create `src/components/admin/ArtworkForm.tsx`
- [ ] Client component (form interactions)
- [ ] Props:
    - [ ] `initialData?: ArtworkFormData` (for edit mode)
    - [ ] `onSubmit: (data: ArtworkFormData) => Promise<void>`
    - [ ] `isLoading?: boolean`
- [ ] Form fields (use Input, Textarea components):
    - [ ] Title (text, required)
    - [ ] Slug (text, required, pattern validation)
    - [ ] Description (textarea)
    - [ ] Price (number)
    - [ ] Original Price (number)
    - [ ] SKU (text)
    - [ ] Inventory Count (number, default 0)
    - [ ] Is Limited Edition (checkbox)
    - [ ] Medium (text)
    - [ ] Dimensions (text)
    - [ ] Year Created (number)
    - [ ] Is Published (checkbox)
    - [ ] Is Featured (checkbox)
    - [ ] Display Order (number)
    - [ ] Image Upload (ImageUploader component - TBD)
    - [ ] Alt Text (text)
    - [ ] SEO Title (text)
    - [ ] SEO Description (textarea)
    - [ ] Tags (text input with comma separation)
- [ ] Use Zod validation with artworkSchema
- [ ] Show validation errors inline
- [ ] Submit button with loading state
- [ ] Cancel button
- [ ] Run tests - should pass

#### 3.2.6: Write Tests for Artwork List Page

**TDD Step: Red**

- [ ] Create `__tests__/app/admin/artwork/page.test.tsx`
- [ ] Write tests:
    - [ ] Renders page title "Artwork Management"
    - [ ] Shows "Add New Artwork" button
    - [ ] Displays artwork in table/grid
    - [ ] Table columns: Thumbnail, Title, Price, Status, Actions
    - [ ] Edit button links to edit page
    - [ ] Delete button shows confirmation
    - [ ] Shows empty state if no artwork
    - [ ] Handles loading state
    - [ ] Handles error state

#### 3.2.7: Implement Artwork List Page

**TDD Step: Green**

- [ ] Create `src/app/admin/artwork/page.tsx`
- [ ] Server component
- [ ] Fetch artwork using `getAllArtworkAdmin()`
- [ ] Layout:
    - [ ] Page header with title "Artwork Management"
    - [ ] "Add New Artwork" button (links to `/admin/artwork/new`)
    - [ ] Table/grid of artwork:
        - [ ] Thumbnail image (if available)
        - [ ] Title
        - [ ] Price (or "N/A")
        - [ ] Status badge (Published/Draft)
        - [ ] Actions: Edit button, Delete button
    - [ ] Empty state message
- [ ] Handle errors gracefully
- [ ] Run tests - should pass

#### 3.2.8: Write Tests for Create Artwork Page

**TDD Step: Red**

- [ ] Create `__tests__/app/admin/artwork/new/page.test.tsx`
- [ ] Write tests:
    - [ ] Renders page title "Create New Artwork"
    - [ ] Renders ArtworkForm component
    - [ ] Form submission creates artwork
    - [ ] Redirects to artwork list on success
    - [ ] Shows error message on failure
    - [ ] Back link to artwork list

#### 3.2.9: Implement Create Artwork Page

**TDD Step: Green**

- [ ] Create `src/app/admin/artwork/new/page.tsx`
- [ ] Client component (form submission requires client-side logic)
- [ ] Use `createArtwork()` query on form submission
- [ ] Use `useRouter()` to redirect on success
- [ ] Layout:
    - [ ] Page title "Create New Artwork"
    - [ ] Back link to `/admin/artwork`
    - [ ] ArtworkForm component with onSubmit handler
    - [ ] Success/error toast messages
- [ ] Handle validation errors from backend
- [ ] Run tests - should pass

#### 3.2.10: Write Tests for Edit Artwork Page

**TDD Step: Red**

- [ ] Create `__tests__/app/admin/artwork/[id]/edit/page.test.tsx`
- [ ] Write tests:
    - [ ] Fetches artwork by ID
    - [ ] Pre-fills form with artwork data
    - [ ] Form submission updates artwork
    - [ ] Redirects on success
    - [ ] Shows 404 if artwork not found
    - [ ] Back link to artwork list

#### 3.2.11: Implement Edit Artwork Page

**TDD Step: Green**

- [ ] Create `src/app/admin/artwork/[id]/edit/page.tsx`
- [ ] Client component
- [ ] Fetch artwork using `getArtworkById(params.id)`
- [ ] Pre-fill ArtworkForm with fetched data
- [ ] Use `updateArtwork()` on form submission
- [ ] Handle 404 error if artwork not found
- [ ] Redirect to `/admin/artwork` on success
- [ ] Run tests - should pass

#### 3.2.12: Write Tests for Delete Artwork Functionality

**TDD Step: Red**

- [ ] Add tests to artwork list page tests:
    - [ ] Delete button shows confirmation dialog
    - [ ] Confirmation calls deleteArtwork()
    - [ ] Artwork removed from list on success
    - [ ] Shows error message on failure
    - [ ] Cancel button closes dialog

#### 3.2.13: Implement Delete Artwork Functionality

**TDD Step: Green**

- [ ] Update `src/app/admin/artwork/page.tsx`:
    - [ ] Add delete confirmation dialog (use browser confirm or modal)
    - [ ] Call `deleteArtwork(id)` on confirmation
    - [ ] Refresh page or remove item from list on success
    - [ ] Show error message on failure
- [ ] Run tests - should pass

#### 3.2.14: Refactor and Verify

**TDD Step: Refactor**

- [ ] Review code quality
- [ ] Run full test suite
- [ ] Manual testing:
    - [ ] Navigate to `/admin/artwork`
    - [ ] Create new artwork
    - [ ] Edit existing artwork
    - [ ] Delete artwork
    - [ ] Verify form validation
    - [ ] Test error handling
- [ ] Lint and format

---

### Phase 3.3: Image Upload System

**Goal**: Build image upload component with Sharp-based optimization and Supabase Storage integration.

#### 3.3.1: Write Tests for Image Optimization Utilities

**TDD Step: Red**

- [ ] Create `__tests__/lib/utils/image.test.ts`
- [ ] Write tests for:
    - [ ] `generateImageVariants(buffer, filename)` - creates 3 sizes
    - [ ] Thumbnail variant is 300px wide
    - [ ] Preview variant is 800px wide
    - [ ] Large variant is 1600px wide
    - [ ] All variants converted to WebP
    - [ ] Maintains aspect ratio
    - [ ] Handles errors (invalid image, corrupt file)
    - [ ] Returns array of { size, buffer, filename }

#### 3.3.2: Implement Image Optimization Utilities

**TDD Step: Green**

- [ ] Create `src/lib/utils/image.ts`
- [ ] Install Sharp if not already: `npm install sharp`
- [ ] Implement `generateImageVariants(buffer: Buffer, filename: string)`:

    ```typescript
    export async function generateImageVariants(
        buffer: Buffer,
        filename: string
    ): Promise<{
        data: Array<{
            size: 'thumbnail' | 'preview' | 'large';
            buffer: Buffer;
            filename: string;
        }> | null;
        error: ImageError | null;
    }> {
        try {
            const image = sharp(buffer);
            const variants = await Promise.all([
                image.clone().resize(300).webp().toBuffer(),
                image.clone().resize(800).webp().toBuffer(),
                image.clone().resize(1600).webp().toBuffer(),
            ]);

            const baseName = filename.replace(/\.[^.]+$/, '');
            return {
                data: [
                    {
                        size: 'thumbnail',
                        buffer: variants[0],
                        filename: `${baseName}-thumb.webp`,
                    },
                    {
                        size: 'preview',
                        buffer: variants[1],
                        filename: `${baseName}-preview.webp`,
                    },
                    {
                        size: 'large',
                        buffer: variants[2],
                        filename: `${baseName}-large.webp`,
                    },
                ],
                error: null,
            };
        } catch (err) {
            return {
                data: null,
                error: {
                    code: 'image_processing_failed',
                    message: 'Failed to process image',
                },
            };
        }
    }
    ```

- [ ] Run tests - should pass

#### 3.3.3: Write Tests for Upload API Route

**TDD Step: Red**

- [ ] Create `__tests__/app/api/admin/upload/route.test.ts`
- [ ] Write tests for POST endpoint:
    - [ ] Accepts multipart/form-data with image file
    - [ ] Validates file type (only images)
    - [ ] Validates file size (max 10MB)
    - [ ] Generates 3 variants
    - [ ] Uploads all variants to Supabase Storage
    - [ ] Returns URLs for all variants
    - [ ] Returns 400 for invalid file type
    - [ ] Returns 413 for file too large
    - [ ] Returns 500 on storage error
    - [ ] Requires authentication (checks session)

#### 3.3.4: Implement Upload API Route

**TDD Step: Green**

- [ ] Create `src/app/api/admin/upload/route.ts`
- [ ] POST handler:
    - [ ] Verify admin session (check cookie or use proxy)
    - [ ] Parse multipart form data (use Next.js FormData)
    - [ ] Validate file type (image/jpeg, image/png, image/webp)
    - [ ] Validate file size (max 10MB)
    - [ ] Read file buffer
    - [ ] Call `generateImageVariants(buffer, filename)`
    - [ ] Upload each variant to Supabase Storage `artwork` bucket:
        ```typescript
        const supabase = createServerClient();
        for (const variant of variants) {
            await supabase.storage
                .from('artwork')
                .upload(`${timestamp}-${variant.filename}`, variant.buffer, {
                    contentType: 'image/webp',
                });
        }
        ```
    - [ ] Return JSON with URLs:
        ```json
        {
            "thumbnail_url": "https://...",
            "preview_url": "https://...",
            "image_url": "https://..."
        }
        ```
    - [ ] Handle errors with proper HTTP status codes
- [ ] Run tests - should pass

#### 3.3.5: Write Tests for ImageUploader Component

**TDD Step: Red**

- [ ] Create `__tests__/components/admin/ImageUploader.test.tsx`
- [ ] Write tests:
    - [ ] Renders file input
    - [ ] Shows "Choose File" button
    - [ ] Accepts only image files (accept attribute)
    - [ ] Displays selected filename
    - [ ] Shows image preview after selection
    - [ ] Upload button disabled until file selected
    - [ ] Shows upload progress (0-100%)
    - [ ] Calls onUploadComplete with URLs on success
    - [ ] Shows error message on failure
    - [ ] Can clear/reset selection
    - [ ] Drag-and-drop support (optional)

#### 3.3.6: Implement ImageUploader Component

**TDD Step: Green**

- [ ] Create `src/components/admin/ImageUploader.tsx`
- [ ] Client component
- [ ] Props:
    - [ ] `onUploadComplete: (urls: { thumbnail_url, preview_url, image_url }) => void`
    - [ ] `existingImageUrl?: string` (show existing image in edit mode)
    - [ ] `maxSizeMB?: number` (default 10)
- [ ] State: selectedFile, preview, uploading, progress, error
- [ ] File input with `accept="image/jpeg,image/png,image/webp"`
- [ ] Image preview using `URL.createObjectURL(file)`
- [ ] Upload button calls `/api/admin/upload`:

    ```typescript
    const formData = new FormData();
    formData.append('file', selectedFile);

    const response = await fetch('/api/admin/upload', {
        method: 'POST',
        body: formData,
    });

    const { thumbnail_url, preview_url, image_url } = await response.json();
    onUploadComplete({ thumbnail_url, preview_url, image_url });
    ```

- [ ] Progress tracking (if supported by fetch)
- [ ] Error handling with user-friendly messages
- [ ] Clear/reset button
- [ ] Run tests - should pass

#### 3.3.7: Integrate ImageUploader into ArtworkForm

**TDD Step: Green (Integration)**

- [ ] Update `src/components/admin/ArtworkForm.tsx`:
    - [ ] Add ImageUploader component
    - [ ] Store uploaded URLs in form state
    - [ ] Pass URLs to onSubmit
    - [ ] Show existing image in edit mode
    - [ ] Allow changing/replacing image
- [ ] Update ArtworkForm tests to include image upload
- [ ] Run tests - should pass

#### 3.3.8: Refactor and Verify

**TDD Step: Refactor**

- [ ] Review code quality
- [ ] Run full test suite
- [ ] Manual testing:
    - [ ] Upload image in create artwork form
    - [ ] Verify 3 variants created in Supabase Storage
    - [ ] Verify URLs stored in database
    - [ ] Test file type validation
    - [ ] Test file size validation
    - [ ] Replace image in edit mode
- [ ] Lint and format

---

### Phase 3.4: Order Management

**Goal**: Build order viewing and status management interface.

#### 3.4.1: Write Tests for Admin Order Queries

**TDD Step: Red**

- [ ] Create `__tests__/lib/db/admin/orders.test.ts`
- [ ] Write tests for:
    - [ ] `getAllOrders(limit, offset, filters)` - paginated orders with filtering
    - [ ] `getOrderById(id)` - single order with order_items joined
    - [ ] `updateOrderStatus(id, status)` - update order status
    - [ ] `addOrderNote(id, note)` - append admin note
    - [ ] `addTrackingNumber(id, tracking)` - add shipping tracking
    - [ ] All functions use server client
    - [ ] Filter by status (pending, paid, shipped, delivered, cancelled)
    - [ ] Filter by date range
    - [ ] Sort by date, amount, status
    - [ ] Error handling

#### 3.4.2: Implement Admin Order Queries

**TDD Step: Green**

- [ ] Create `src/lib/db/admin/orders.ts`
- [ ] Implement query functions:
    - [ ] `getAllOrders()` with pagination and filters
    - [ ] `getOrderById()` with order_items join
    - [ ] `updateOrderStatus()`
    - [ ] `addOrderNote()`
    - [ ] `addTrackingNumber()`
- [ ] Use server client (service role)
- [ ] Define `OrderFilters` and `OrderAdminError` types
- [ ] Run tests - should pass

#### 3.4.3: Write Tests for OrdersList Component

**TDD Step: Red**

- [ ] Create `__tests__/components/admin/OrdersList.test.tsx`
- [ ] Write tests:
    - [ ] Renders table with columns: Order Number, Customer, Date, Total, Status, Actions
    - [ ] Displays order data correctly
    - [ ] View button links to order detail page
    - [ ] Status badge colors (pending: yellow, paid: green, shipped: blue, etc.)
    - [ ] Pagination controls
    - [ ] Sorting by column (click headers)
    - [ ] Shows empty state
    - [ ] Loading state

#### 3.4.4: Implement OrdersList Component

**TDD Step: Green**

- [ ] Create `src/components/admin/OrdersList.tsx`
- [ ] Props:
    - [ ] `orders: Order[]`
    - [ ] `currentPage: number`
    - [ ] `totalPages: number`
    - [ ] `onPageChange: (page: number) => void`
- [ ] Table with columns: Order Number, Customer Name, Date, Total Amount, Status, Actions
- [ ] Status badges with colors (use existing Button/Badge patterns)
- [ ] "View Details" button links to `/admin/orders/[id]`
- [ ] Pagination controls (Previous/Next buttons, page numbers)
- [ ] Run tests - should pass

#### 3.4.5: Write Tests for Orders List Page

**TDD Step: Red**

- [ ] Create `__tests__/app/admin/orders/page.test.tsx`
- [ ] Write tests:
    - [ ] Renders page title "Orders"
    - [ ] Fetches orders with pagination
    - [ ] Displays OrdersList component
    - [ ] Filter controls (status dropdown, date range)
    - [ ] Applying filters refetches orders
    - [ ] Handles loading state
    - [ ] Handles error state

#### 3.4.6: Implement Orders List Page

**TDD Step: Green**

- [ ] Create `src/app/admin/orders/page.tsx`
- [ ] Server component with search params for pagination/filters
- [ ] Fetch orders using `getAllOrders(limit, offset, filters)`
- [ ] Layout:
    - [ ] Page title "Orders"
    - [ ] Filter controls:
        - [ ] Status dropdown (All, Pending, Paid, Shipped, Delivered, Cancelled)
        - [ ] Date range picker (optional for MVP)
    - [ ] OrdersList component with orders data
    - [ ] Pagination (pass page number via URL search params)
- [ ] Handle errors gracefully
- [ ] Run tests - should pass

#### 3.4.7: Write Tests for Order Detail Page

**TDD Step: Red**

- [ ] Create `__tests__/app/admin/orders/[id]/page.test.tsx`
- [ ] Write tests:
    - [ ] Fetches order by ID
    - [ ] Displays order information (number, date, status, customer, addresses)
    - [ ] Shows order items table (product, quantity, price, subtotal)
    - [ ] Displays totals (subtotal, shipping, tax, total)
    - [ ] Status update dropdown
    - [ ] Updating status calls updateOrderStatus()
    - [ ] Admin notes field (textarea)
    - [ ] Tracking number input
    - [ ] Save buttons for notes and tracking
    - [ ] Shows 404 if order not found
    - [ ] Back link to orders list

#### 3.4.8: Implement Order Detail Page

**TDD Step: Green**

- [ ] Create `src/app/admin/orders/[id]/page.tsx`
- [ ] Client component (status updates require client-side logic)
- [ ] Fetch order using `getOrderById(params.id)`
- [ ] Handle 404 if order not found
- [ ] Layout:
    - [ ] Page title "Order #[order_number]"
    - [ ] Back link to `/admin/orders`
    - [ ] Order information card:
        - [ ] Order date, status badge
        - [ ] Customer name, email
        - [ ] Shipping address
        - [ ] Billing address (if different)
    - [ ] Order items table:
        - [ ] Columns: Product, Quantity, Price, Subtotal
        - [ ] Row for each order_item
    - [ ] Totals summary:
        - [ ] Subtotal
        - [ ] Shipping
        - [ ] Tax
        - [ ] **Total**
    - [ ] Admin actions:
        - [ ] Status dropdown (pending, paid, shipped, delivered, cancelled)
        - [ ] Update Status button
        - [ ] Admin notes textarea
        - [ ] Save Notes button
        - [ ] Tracking number input
        - [ ] Save Tracking button
- [ ] Status update calls `updateOrderStatus(id, status)`
- [ ] Notes save calls `addOrderNote(id, note)`
- [ ] Tracking save calls `addTrackingNumber(id, tracking)`
- [ ] Show success/error messages
- [ ] Run tests - should pass

#### 3.4.9: Refactor and Verify

**TDD Step: Refactor**

- [ ] Review code quality
- [ ] Run full test suite
- [ ] Manual testing:
    - [ ] Navigate to `/admin/orders`
    - [ ] View order list
    - [ ] Filter by status
    - [ ] Paginate through orders
    - [ ] Click order to view details
    - [ ] Update order status
    - [ ] Add admin note
    - [ ] Add tracking number
    - [ ] Verify back navigation
- [ ] Lint and format

---

### Phase 3.5: Projects & Events Management

**Goal**: Build CRUD interfaces for projects and events (similar to artwork management).

#### 3.5.1: Write Tests for Admin Projects Queries

**TDD Step: Red**

- [ ] Create `__tests__/lib/db/admin/projects.test.ts`
- [ ] Write tests for:
    - [ ] `getAllProjectsAdmin()` - all projects (not just published)
    - [ ] `getProjectById(id)`
    - [ ] `createProject(data)`
    - [ ] `updateProject(id, data)`
    - [ ] `deleteProject(id)`
    - [ ] All use server client
    - [ ] Error handling

#### 3.5.2: Implement Admin Projects Queries

**TDD Step: Green**

- [ ] Create `src/lib/db/admin/projects.ts`
- [ ] Implement all CRUD functions
- [ ] Use server client
- [ ] Define `ProjectInput` and `ProjectAdminError` types
- [ ] Run tests - should pass

#### 3.5.3: Create Project Validation Schema

**TDD Step: Green (Preparation)**

- [ ] Create `src/lib/validation/project.ts`
- [ ] Define Zod schema for project:
    ```typescript
    export const projectSchema = z.object({
        title: z.string().min(1, 'Title is required'),
        slug: z
            .string()
            .min(1, 'Slug is required')
            .regex(/^[a-z0-9-]+$/),
        description: z.string().optional(),
        status: z
            .enum(['planning', 'active', 'completed', 'archived'])
            .default('planning'),
        progress_percentage: z.number().int().min(0).max(100).default(0),
        expected_completion_date: z.string().optional(), // ISO date string
        is_published: z.boolean().default(false),
        display_order: z.number().int().default(0),
        image_url: z.string().url().optional(),
        thumbnail_url: z.string().url().optional(),
    });
    ```

#### 3.5.4: Write Tests for ProjectForm Component

**TDD Step: Red**

- [ ] Create `__tests__/components/admin/ProjectForm.test.tsx`
- [ ] Write tests (similar to ArtworkForm):
    - [ ] Renders all fields
    - [ ] Validates required fields
    - [ ] Shows validation errors
    - [ ] Calls onSubmit
    - [ ] Pre-fills in edit mode
    - [ ] Image upload integration

#### 3.5.5: Implement ProjectForm Component

**TDD Step: Green**

- [ ] Create `src/components/admin/ProjectForm.tsx`
- [ ] Follow ArtworkForm pattern
- [ ] Form fields:
    - [ ] Title, Slug, Description
    - [ ] Status dropdown (planning, active, completed, archived)
    - [ ] Progress percentage (0-100 slider or number input)
    - [ ] Expected completion date (date picker)
    - [ ] Is Published checkbox
    - [ ] Display Order
    - [ ] Image upload (ImageUploader)
- [ ] Use projectSchema for validation
- [ ] Run tests - should pass

#### 3.5.6: Implement Projects CRUD Pages

**TDD Step: Red then Green**

- [ ] Create `__tests__/app/admin/projects/page.test.tsx` (list page tests)
- [ ] Create `src/app/admin/projects/page.tsx` (list page)
- [ ] Create `__tests__/app/admin/projects/new/page.test.tsx` (create page tests)
- [ ] Create `src/app/admin/projects/new/page.tsx` (create page)
- [ ] Create `__tests__/app/admin/projects/[id]/edit/page.test.tsx` (edit page tests)
- [ ] Create `src/app/admin/projects/[id]/edit/page.tsx` (edit page)
- [ ] Follow same patterns as artwork management
- [ ] Run tests for each page - should pass

#### 3.5.7: Write Tests for Admin Events Queries

**TDD Step: Red**

- [ ] Create `__tests__/lib/db/admin/events.test.ts`
- [ ] Write tests for:
    - [ ] `getAllEventsAdmin()`
    - [ ] `getEventById(id)`
    - [ ] `createEvent(data)`
    - [ ] `updateEvent(id, data)`
    - [ ] `deleteEvent(id)`
    - [ ] All use server client

#### 3.5.8: Implement Admin Events Queries

**TDD Step: Green**

- [ ] Create `src/lib/db/admin/events.ts`
- [ ] Implement all CRUD functions
- [ ] Use server client
- [ ] Define `EventInput` and `EventAdminError` types
- [ ] Run tests - should pass

#### 3.5.9: Create Event Validation Schema

**TDD Step: Green (Preparation)**

- [ ] Create `src/lib/validation/event.ts`
- [ ] Define Zod schema for event:
    ```typescript
    export const eventSchema = z.object({
        title: z.string().min(1, 'Title is required'),
        slug: z
            .string()
            .min(1, 'Slug is required')
            .regex(/^[a-z0-9-]+$/),
        description: z.string().optional(),
        start_date: z.string().min(1, 'Start date is required'), // ISO date
        end_date: z.string().optional(), // ISO date
        location: z.string().optional(),
        venue_name: z.string().optional(),
        booth_number: z.string().optional(),
        convention_url: z.string().url().optional(),
        is_published: z.boolean().default(false),
        image_url: z.string().url().optional(),
        thumbnail_url: z.string().url().optional(),
    });
    ```

#### 3.5.10: Write Tests for EventForm Component

**TDD Step: Red**

- [ ] Create `__tests__/components/admin/EventForm.test.tsx`
- [ ] Write tests (similar to ArtworkForm/ProjectForm)

#### 3.5.11: Implement EventForm Component

**TDD Step: Green**

- [ ] Create `src/components/admin/EventForm.tsx`
- [ ] Form fields:
    - [ ] Title, Slug, Description
    - [ ] Start Date (date picker, required)
    - [ ] End Date (date picker, optional)
    - [ ] Location, Venue Name, Booth Number
    - [ ] Convention URL
    - [ ] Is Published checkbox
    - [ ] Image upload
- [ ] Use eventSchema for validation
- [ ] Run tests - should pass

#### 3.5.12: Implement Events CRUD Pages

**TDD Step: Red then Green**

- [ ] Create tests and pages for:
    - [ ] `/admin/events` (list page)
    - [ ] `/admin/events/new` (create page)
    - [ ] `/admin/events/[id]/edit` (edit page)
- [ ] Follow same patterns as artwork/projects management
- [ ] Run tests - should pass

#### 3.5.13: Refactor and Verify

**TDD Step: Refactor**

- [ ] Review code quality across projects and events
- [ ] Run full test suite
- [ ] Manual testing:
    - [ ] Create/edit/delete projects
    - [ ] Create/edit/delete events
    - [ ] Upload images for both
    - [ ] Verify validation
- [ ] Lint and format

---

### Phase 3.6: Cache Revalidation

**Goal**: Implement on-demand cache revalidation when admin changes content.

#### 3.6.1: Write Tests for Revalidation API Route

**TDD Step: Red**

- [ ] Create `__tests__/app/api/admin/revalidate/route.test.ts`
- [ ] Write tests for POST endpoint:
    - [ ] Accepts { path: string } or { tag: string }
    - [ ] Calls next/cache revalidatePath() for path
    - [ ] Calls next/cache revalidateTag() for tag
    - [ ] Returns 200 with success message
    - [ ] Returns 400 if no path or tag provided
    - [ ] Returns 401 if not authenticated (checks session)
    - [ ] Returns 500 on revalidation error

#### 3.6.2: Implement Revalidation API Route

**TDD Step: Green**

- [ ] Create `src/app/api/admin/revalidate/route.ts`
- [ ] POST handler:
    - [ ] Verify admin session (proxy or manual check)
    - [ ] Parse request body: `{ path?: string, tag?: string }`
    - [ ] If path provided:
        ```typescript
        import { revalidatePath } from 'next/cache';
        revalidatePath(path);
        ```
    - [ ] If tag provided:
        ```typescript
        import { revalidateTag } from 'next/cache';
        revalidateTag(tag);
        ```
    - [ ] Return `{ success: true, message: 'Cache revalidated' }`
    - [ ] Handle errors with proper status codes
- [ ] Run tests - should pass

#### 3.6.3: Integrate Revalidation into Admin Actions

**TDD Step: Green (Integration)**

- [ ] Update artwork create/update/delete functions:
    - [ ] After successful mutation, call `/api/admin/revalidate`:

        ```typescript
        await fetch('/api/admin/revalidate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path: '/gallery' }),
        });

        await fetch('/api/admin/revalidate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path: '/shoppe' }),
        });
        ```

    - [ ] Also revalidate `/gallery/[slug]` for specific artwork

- [ ] Update projects create/update/delete:
    - [ ] Revalidate `/in-the-works` path
- [ ] Update events create/update/delete:
    - [ ] Revalidate `/in-the-works` path
- [ ] Test that public pages update after admin changes

#### 3.6.4: Refactor and Verify

**TDD Step: Refactor**

- [ ] Review revalidation logic
- [ ] Run full test suite
- [ ] Manual testing:
    - [ ] Create artwork in admin
    - [ ] Verify it appears on `/gallery` immediately
    - [ ] Update artwork
    - [ ] Verify changes appear on `/gallery/[slug]`
    - [ ] Delete artwork
    - [ ] Verify it disappears from `/gallery`
    - [ ] Repeat for projects and events
- [ ] Lint and format

---

### Phase 3.7: Settings & Admin User Management (Super Admin Only)

**Goal**: Allow super admins to manage admin users and site settings.

#### 3.7.1: Write Tests for Admin User Queries

**TDD Step: Red**

- [ ] Create `__tests__/lib/db/admin/administrators.test.ts`
- [ ] Write tests for:
    - [ ] `getAllAdmins()` - list all administrators
    - [ ] `getAdminById(id)`
    - [ ] `createAdmin(data)` - create new admin user (also creates Supabase Auth user)
    - [ ] `updateAdmin(id, data)` - update name, role, is_active
    - [ ] `deactivateAdmin(id)` - set is_active = false
    - [ ] Test role validation (only 'admin' or 'super_admin')
    - [ ] Test email uniqueness
    - [ ] All use server client

#### 3.7.2: Implement Admin User Queries

**TDD Step: Green**

- [ ] Create `src/lib/db/admin/administrators.ts`
- [ ] Implement query functions:
    - [ ] `getAllAdmins()`
    - [ ] `getAdminById(id)`
    - [ ] `createAdmin(data)` - **Important**: Must also create Supabase Auth user:

        ```typescript
        const { data: authUser, error: authError } = await supabase.auth.admin.createUser({
            email: data.email,
            password: data.password, // temporary password, force reset
            email_confirm: true,
        });

        if (authError) return { data: null, error: { ... } };

        const { data: admin, error } = await supabase
            .from('administrators')
            .insert({
                auth_id: authUser.user.id,
                name: data.name,
                email: data.email,
                role: data.role,
            })
            .select()
            .single();
        ```

    - [ ] `updateAdmin(id, data)`
    - [ ] `deactivateAdmin(id)` - set is_active = false (don't delete)

- [ ] Use server client (service role)
- [ ] Define `AdminInput` and `AdminError` types
- [ ] Run tests - should pass

#### 3.7.3: Write Tests for AdminForm Component

**TDD Step: Red**

- [ ] Create `__tests__/components/admin/AdminForm.test.tsx`
- [ ] Write tests:
    - [ ] Renders name, email, role, password fields
    - [ ] Validates required fields
    - [ ] Password field only shown for new admin (not edit)
    - [ ] Role dropdown (admin, super_admin)
    - [ ] Is Active checkbox (edit mode only)
    - [ ] Calls onSubmit with form data
    - [ ] Shows validation errors

#### 3.7.4: Implement AdminForm Component

**TDD Step: Green**

- [ ] Create `src/components/admin/AdminForm.tsx`
- [ ] Form fields:
    - [ ] Name (text, required)
    - [ ] Email (email, required)
    - [ ] Role (select: admin, super_admin)
    - [ ] Password (password, required for new admin only)
    - [ ] Is Active (checkbox, edit mode only)
- [ ] Validation schema:
    ```typescript
    const adminSchema = z.object({
        name: z.string().min(1),
        email: z.string().email(),
        role: z.enum(['admin', 'super_admin']),
        password: z.string().min(8).optional(),
        is_active: z.boolean().default(true),
    });
    ```
- [ ] Run tests - should pass

#### 3.7.5: Write Tests for Settings Page

**TDD Step: Red**

- [ ] Create `__tests__/app/admin/settings/page.test.tsx`
- [ ] Write tests:
    - [ ] Page only accessible to super_admin (redirects otherwise)
    - [ ] Shows "Admin Users" section
    - [ ] Lists all administrators
    - [ ] "Add New Admin" button
    - [ ] Edit/Deactivate buttons for each admin
    - [ ] Cannot deactivate yourself (current logged-in admin)
    - [ ] Shows site settings section (placeholder for MVP)

#### 3.7.6: Implement Settings Page

**TDD Step: Green**

- [ ] Create `src/app/admin/settings/page.tsx`
- [ ] Client component (role check requires session)
- [ ] Check current admin role from admin_session cookie
- [ ] If role !== 'super_admin', redirect to `/admin` with error message
- [ ] Fetch all admins using `getAllAdmins()`
- [ ] Layout:
    - [ ] Page title "Settings"
    - [ ] **Admin Users** section:
        - [ ] Table: Name, Email, Role, Status, Actions
        - [ ] "Add New Admin" button (opens form dialog)
        - [ ] Edit button (opens form dialog pre-filled)
        - [ ] Deactivate button (disabled for self)
    - [ ] **Site Settings** section (placeholder for MVP):
        - [ ] "Coming soon" message
        - [ ] Note: Shipping cost, social links, etc. can be added here in future
- [ ] Modal/dialog for adding/editing admins (use AdminForm)
- [ ] Deactivate calls `deactivateAdmin(id)`
- [ ] Run tests - should pass

#### 3.7.7: Refactor and Verify

**TDD Step: Refactor**

- [ ] Review code quality
- [ ] Run full test suite
- [ ] Manual testing:
    - [ ] Login as super_admin
    - [ ] Navigate to `/admin/settings`
    - [ ] View admin users list
    - [ ] Add new admin
    - [ ] Edit existing admin
    - [ ] Deactivate admin (verify cannot deactivate self)
    - [ ] Test with regular admin role (should redirect)
- [ ] Lint and format

---

### Phase 3.8: Final Testing & Polish

**Goal**: Ensure comprehensive test coverage, handle edge cases, and polish the admin experience.

#### 3.8.1: Coverage Analysis

- [ ] Run coverage report: `npm run test:coverage`
- [ ] Review coverage by module:
    - [ ] `src/lib/db/admin/`: Target 100%
    - [ ] `src/components/admin/`: Target 80-85%
    - [ ] `src/app/admin/`: Target 70%+
    - [ ] `src/app/api/admin/`: Target 90%+
- [ ] Identify uncovered lines and add tests

#### 3.8.2: Integration Testing

- [ ] Create `__tests__/integration/admin-workflow.test.ts`
- [ ] Test complete admin workflows:
    - [ ] Login → Dashboard → Create Artwork → View in Gallery
    - [ ] Login → Orders → View Order Detail → Update Status
    - [ ] Login → Projects → Create Project → View in In The Works
    - [ ] Super Admin → Settings → Add Admin → Logout → Login as New Admin

#### 3.8.3: Error Handling Audit

- [ ] Review all admin pages for error handling:
    - [ ] Database query failures show user-friendly messages
    - [ ] Form validation errors are clear and actionable
    - [ ] Network errors (image upload, API calls) are handled
    - [ ] 404 pages for missing resources
    - [ ] 403 pages for insufficient permissions
- [ ] Add error boundaries where missing

#### 3.8.4: Accessibility Audit

- [ ] Test keyboard navigation:
    - [ ] Tab through all forms
    - [ ] Submit forms with Enter key
    - [ ] Close modals with Escape key
- [ ] Test with screen reader (if possible)
- [ ] Ensure all form inputs have labels
- [ ] Check color contrast (especially for status badges)
- [ ] Add ARIA labels where needed

#### 3.8.5: Loading States

- [ ] Audit all pages for loading states:
    - [ ] Dashboard metrics loading
    - [ ] Tables loading (artwork, orders, projects, events)
    - [ ] Form submission loading (disable buttons, show spinner)
    - [ ] Image upload progress
- [ ] Add skeleton loaders or spinners where missing

#### 3.8.6: Responsive Design

- [ ] Test all admin pages on mobile:
    - [ ] Sidebar collapses to hamburger menu
    - [ ] Tables scroll horizontally or stack vertically
    - [ ] Forms are usable on small screens
    - [ ] Image uploader works on mobile
- [ ] Test on tablet (iPad-sized)
- [ ] Ensure touch targets are 44x44px minimum

#### 3.8.7: Security Review

- [ ] Verify all admin routes protected by proxy
- [ ] Ensure service role client used for all admin queries
- [ ] Check that super_admin-only features are properly gated
- [ ] Verify image upload validates file types and sizes
- [ ] Test SQL injection prevention (Supabase handles this, but verify)
- [ ] Ensure sensitive errors not exposed to client

#### 3.8.8: Performance Review

- [ ] Check bundle size: `npm run build` and review output
- [ ] Verify image optimization (WebP, proper sizes)
- [ ] Ensure database queries use indexes (already set in Phase 1)
- [ ] Test pagination on large datasets
- [ ] Check for unnecessary re-renders in React components

#### 3.8.9: Documentation

- [ ] Add JSDoc comments to all admin query functions
- [ ] Document component props with TypeScript interfaces
- [ ] Update CLAUDE.md with admin architecture details (if needed)
- [ ] Add inline comments for complex logic

#### 3.8.10: Final Manual Testing

- [ ] Complete end-to-end test as regular admin:
    - [ ] Login
    - [ ] View dashboard
    - [ ] Create artwork with image
    - [ ] Edit artwork
    - [ ] Delete artwork
    - [ ] View orders
    - [ ] Update order status
    - [ ] Create project
    - [ ] Create event
    - [ ] Logout
- [ ] Complete end-to-end test as super_admin:
    - [ ] All of the above
    - [ ] Access settings
    - [ ] Add new admin
    - [ ] Edit admin
    - [ ] Deactivate admin

#### 3.8.11: Lint and Format

- [ ] Run linter: `npm run lint`
- [ ] Fix all errors and warnings
- [ ] Run formatter: `npm run format`
- [ ] Commit all changes

---

## Deliverables

Upon completion of Phase 3, the following will be delivered:

### Functional Deliverables

- ✅ Complete admin dashboard with metrics and recent orders
- ✅ Artwork management (CRUD with image upload)
- ✅ Projects management (CRUD with image upload)
- ✅ Events management (CRUD with image upload)
- ✅ Order management (view, update status, add notes, add tracking)
- ✅ Image upload system with 3 variants (thumbnail, preview, large)
- ✅ Cache revalidation on content changes
- ✅ Role-based access control (admin vs super_admin)
- ✅ Admin user management (super_admin only)

### Technical Deliverables

- ✅ Admin database query functions in `src/lib/db/admin/`
- ✅ Admin UI components in `src/components/admin/`
- ✅ Admin pages in `src/app/admin/`
- ✅ Admin API routes in `src/app/api/admin/`
- ✅ Comprehensive test coverage (80%+ for components, 100% for queries)
- ✅ Zod validation schemas for all forms
- ✅ Proper error handling and user feedback
- ✅ Responsive design for all admin pages
- ✅ Accessibility compliance

---

## Verification Checklist

Before considering Phase 3 complete, verify:

### Authentication & Authorization

- [ ] Admin login works
- [ ] proxy protects `/admin/*` routes
- [ ] Session caching works (15-minute TTL)
- [ ] Logout clears session and redirects
- [ ] Super admin features hidden from regular admins
- [ ] Regular admins cannot access `/admin/settings`

### Dashboard

- [ ] Dashboard loads without errors
- [ ] Metrics display correctly (even if 0)
- [ ] Recent orders list displays
- [ ] Links to order details work
- [ ] Admin header displays with logo, user name, logout button
- [ ] Desktop: Horizontal menu bar displays navigation links
- [ ] Desktop: Active route highlighted in menu bar
- [ ] Mobile: Hamburger menu button appears
- [ ] Mobile: Sidebar navigation slides in/out
- [ ] Mobile: Backdrop overlay works
- [ ] All navigation links route correctly
- [ ] Responsive layout on mobile

### Artwork Management

- [ ] Can view all artwork (published and unpublished)
- [ ] Can create new artwork with all fields
- [ ] Can upload image and see 3 variants in Supabase Storage
- [ ] Can edit existing artwork
- [ ] Can delete artwork (with confirmation)
- [ ] Form validation works
- [ ] Changes appear on public `/gallery` immediately (cache revalidation)

### Projects & Events Management

- [ ] Can create/edit/delete projects
- [ ] Can create/edit/delete events
- [ ] Image upload works for both
- [ ] Changes appear on `/in-the-works` immediately

### Order Management

- [ ] Can view all orders with pagination
- [ ] Can filter orders by status
- [ ] Can view order details
- [ ] Can update order status
- [ ] Can add admin notes
- [ ] Can add tracking number
- [ ] Changes save successfully

### Image Upload

- [ ] Can upload images (JPEG, PNG, WebP)
- [ ] File type validation rejects non-images
- [ ] File size validation rejects files >10MB
- [ ] 3 variants generated (thumbnail, preview, large)
- [ ] All variants uploaded to Supabase Storage
- [ ] URLs returned and stored in database
- [ ] Preview shows uploaded image

### Settings (Super Admin)

- [ ] Settings page only accessible to super_admin
- [ ] Can view all admin users
- [ ] Can add new admin user
- [ ] Can edit existing admin
- [ ] Can deactivate admin (but not self)
- [ ] Cannot deactivate self

### Testing

- [ ] All tests pass: `npm test`
- [ ] Coverage meets targets: `npm run test:coverage`
- [ ] No linting errors: `npm run lint`
- [ ] Code formatted: `npm run format`

### Performance & UX

- [ ] All pages load in <2 seconds
- [ ] No console errors or warnings
- [ ] Loading states show during async operations
- [ ] Error messages are user-friendly
- [ ] Forms have proper validation feedback
- [ ] Responsive design works on mobile/tablet

---

## Known Limitations (Out of Scope for Phase 3)

The following features are **not** included in Phase 3 and may be added in future phases:

- **Page content management**: Managing `/about`, `/policies`, etc. (deferred)
- **Bulk upload**: Uploading multiple images at once
- **Advanced filtering**: Complex order filters (date ranges, amount ranges)
- **Email notifications**: Sending emails on order status changes (Phase 5)
- **Order refunds**: Handling refunds via Stripe
- **Inventory alerts**: Notifications for low inventory
- **Analytics dashboard**: Charts and graphs (Phase 6)
- **Audit log**: Tracking admin actions
- **Rich text editor**: WYSIWYG editor for descriptions (using plain textarea for MVP)

---

## Next Steps After Phase 3

Once Phase 3 is complete and verified:

1. **Code Review**: Review all code for quality and consistency
2. **Documentation**: Update project documentation with admin system details
3. **Demo**: Demo the admin system to stakeholders
4. **Proceed to Phase 4**: Shopping cart and checkout implementation

**Next Phase**: [Phase 4: Shopping Cart & Checkout](./2025-10-25T17-55-00-mvp-implementation-plan.md#phase-4-shopping-cart--checkout-week-5)

---

## Appendix: Code Patterns Reference

### Database Query Function Pattern

```typescript
export async function queryName(params): Promise<{
    data: T | null;
    error: ErrorType | null;
}> {
    try {
        const supabase = createServerClient(); // Use service role for admin

        const { data, error } = await supabase.from('table_name').select('*');
        // ... query logic

        if (error) {
            return {
                data: null,
                error: {
                    code: error.code || 'unknown',
                    message: error.message,
                },
            };
        }

        return { data, error: null };
    } catch (err) {
        console.error('queryName failed:', err);
        return {
            data: null,
            error: {
                code: 'fetch_error',
                message: 'User-friendly error message',
                ...(process.env.NODE_ENV === 'development' && {
                    details:
                        err instanceof Error ? err.message : 'Unknown error',
                }),
            },
        };
    }
}
```

### Component Pattern

```typescript
export interface ComponentNameProps
    extends React.HTMLAttributes<HTMLDivElement> {
    variant?: 'primary' | 'secondary';
    size?: 'sm' | 'md' | 'lg';
    children: React.ReactNode;
}

export function ComponentName({
    variant = 'primary',
    size = 'md',
    className = '',
    children,
    ...props
}: ComponentNameProps) {
    return (
        <div
            className={`base-classes ${variantClasses[variant]} ${sizeClasses[size]} ${className}`}
            {...props}
        >
            {children}
        </div>
    );
}
```

### Form Validation Pattern (React Hook Form + Zod)

```typescript
import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

// Define validation schema
export const formSchema = z.object({
    field1: z.string().min(1, 'Field 1 is required'),
    field2: z.number().min(0),
    field3: z.boolean().default(false),
});

export type FormData = z.infer<typeof formSchema>;

// In component:
export function MyForm() {
    const {
        register,
        handleSubmit,
        formState: { errors, isSubmitting }
    } = useForm<FormData>({
        resolver: zodResolver(formSchema),
        defaultValues: {
            field1: '',
            field2: 0,
            field3: false,
        },
    });

    const onSubmit = async (data: FormData) => {
        // Call Server Action
        const { data: result, error } = await myServerAction(data);
        if (error) {
            alert(`Error: ${error.message}`);
        } else {
            alert('Success!');
        }
    };

    return (
        <form onSubmit={handleSubmit(onSubmit)}>
            <input {...register('field1')} />
            {errors.field1 && <span>{errors.field1.message}</span>}

            <input type="number" {...register('field2', { valueAsNumber: true })} />
            {errors.field2 && <span>{errors.field2.message}</span>}

            <input type="checkbox" {...register('field3')} />

            <button type="submit" disabled={isSubmitting}>
                {isSubmitting ? 'Submitting...' : 'Submit'}
            </button>
        </form>
    );
}
```

### Test Pattern

```typescript
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ComponentName } from '@/components/ComponentName';

describe('ComponentName', () => {
    it('renders without crashing', () => {
        render(<ComponentName>Content</ComponentName>);
        expect(screen.getByText('Content')).toBeInTheDocument();
    });

    it('handles user interactions', async () => {
        const onClickMock = jest.fn();
        render(<ComponentName onClick={onClickMock} />);

        const button = screen.getByRole('button');
        await userEvent.click(button);

        expect(onClickMock).toHaveBeenCalledTimes(1);
    });

    it('shows error state', () => {
        render(<ComponentName error="Error message" />);
        expect(screen.getByText('Error message')).toBeInTheDocument();
    });
});
```

### Server Action Pattern (Complete Example)

```typescript
// src/app/admin/artwork/actions.ts
'use server';

import { revalidatePath } from 'next/cache';
import {
    createArtwork,
    updateArtwork,
    deleteArtwork,
} from '@/lib/db/admin/artwork';
import type { ArtworkInput } from '@/lib/validation/artwork';

export async function createArtworkAction(data: ArtworkInput) {
    const result = await createArtwork(data);

    if (result.data) {
        revalidatePath('/gallery');
        revalidatePath('/shoppe');
    }

    return result;
}

export async function updateArtworkAction(
    id: string,
    data: Partial<ArtworkInput>
) {
    const result = await updateArtwork(id, data);

    if (result.data) {
        revalidatePath('/gallery');
        revalidatePath(`/gallery/${result.data.slug}`);
        revalidatePath('/shoppe');
    }

    return result;
}

export async function deleteArtworkAction(id: string) {
    const result = await deleteArtwork(id);

    if (result.data) {
        revalidatePath('/gallery');
        revalidatePath('/shoppe');
    }

    return result;
}
```

### Admin Layout Pattern (Server Component)

```typescript
// src/app/admin/layout.tsx
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';
import { AdminLayoutClient } from './AdminLayoutClient';

export default async function AdminLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    const cookieStore = await cookies();
    const sessionCookie = cookieStore.get('admin_session');

    if (!sessionCookie) {
        redirect('/admin/login');
    }

    let session;
    try {
        session = JSON.parse(sessionCookie.value);
    } catch {
        redirect('/admin/login');
    }

    // Pass session data to client component for interactivity
    return (
        <AdminLayoutClient
            adminName={session.name}
            role={session.role}
        >
            {children}
        </AdminLayoutClient>
    );
}
```

```typescript
// src/app/admin/AdminLayoutClient.tsx
'use client'

import { useState } from 'react';
import { AdminHeader } from '@/components/admin/AdminHeader';
import { AdminNavigation } from '@/components/admin/AdminNavigation';

export function AdminLayoutClient({
    adminName,
    role,
    children,
}: {
    adminName: string;
    role: 'admin' | 'super_admin';
    children: React.ReactNode;
}) {
    const [mobileMenuOpen, setMobileMenuOpen] = useState(false);

    return (
        <div className="min-h-screen bg-gray-50">
            <AdminHeader
                adminName={adminName}
                onMenuToggle={() => setMobileMenuOpen(!mobileMenuOpen)}
            />
            <AdminNavigation
                role={role}
                isOpen={mobileMenuOpen}
                onClose={() => setMobileMenuOpen(false)}
            />
            <main className="lg:ml-0 pt-28 lg:pt-24 px-4 pb-8">
                {children}
            </main>
        </div>
    );
}
```

### Image Upload API Route Pattern

```typescript
// src/app/api/admin/upload/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { createServerClient } from '@/lib/supabase/server';
import { generateImageVariants } from '@/lib/utils/image';

export async function POST(request: NextRequest) {
    // 1. Verify admin session
    const cookieStore = await cookies();
    const sessionCookie = cookieStore.get('admin_session');

    if (!sessionCookie) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    try {
        const session = JSON.parse(sessionCookie.value);
        if (!session.userId || session.expiresAt < Date.now()) {
            return NextResponse.json(
                { error: 'Session expired' },
                { status: 401 }
            );
        }
    } catch {
        return NextResponse.json({ error: 'Invalid session' }, { status: 401 });
    }

    // 2. Parse multipart form data
    const formData = await request.formData();
    const file = formData.get('file') as File;

    if (!file) {
        return NextResponse.json(
            { error: 'No file provided' },
            { status: 400 }
        );
    }

    // 3. Validate file type
    if (!file.type.startsWith('image/')) {
        return NextResponse.json(
            { error: 'File must be an image' },
            { status: 400 }
        );
    }

    // 4. Validate file size (10MB max)
    if (file.size > 10 * 1024 * 1024) {
        return NextResponse.json(
            { error: 'File too large (max 10MB)' },
            { status: 413 }
        );
    }

    // 5. Convert file to buffer
    const buffer = Buffer.from(await file.arrayBuffer());

    // 6. Generate image variants
    const { data: variants, error: imageError } = await generateImageVariants(
        buffer,
        file.name
    );

    if (imageError || !variants) {
        return NextResponse.json(
            { error: 'Failed to process image' },
            { status: 500 }
        );
    }

    // 7. Upload to Supabase Storage
    const supabase = createServerClient();
    const timestamp = Date.now();
    const urls: Record<string, string> = {};

    for (const variant of variants) {
        const filename = `${timestamp}-${variant.filename}`;
        const { error: uploadError } = await supabase.storage
            .from('artwork')
            .upload(filename, variant.buffer, {
                contentType: 'image/webp',
            });

        if (uploadError) {
            return NextResponse.json(
                { error: 'Failed to upload image' },
                { status: 500 }
            );
        }

        const {
            data: { publicUrl },
        } = supabase.storage.from('artwork').getPublicUrl(filename);

        // Map to database field names
        if (variant.size === 'thumbnail') {
            urls.image_thumbnail_url = publicUrl;
        } else if (variant.size === 'preview') {
            urls.image_url = publicUrl;
        } else if (variant.size === 'large') {
            urls.image_large_url = publicUrl;
        }
    }

    return NextResponse.json(urls);
}
```

### User Feedback Pattern (Alerts for MVP)

```typescript
// For MVP, use browser alerts for user feedback
// Future: Replace with toast library (e.g., react-hot-toast)

// Success message
const handleSuccess = () => {
    alert('Artwork created successfully!');
    router.push('/admin/artwork');
};

// Error message
const handleError = (error: { message: string }) => {
    alert(`Error: ${error.message}`);
};

// Confirmation dialog
const handleDelete = async (id: string) => {
    if (
        confirm(
            'Are you sure you want to delete this artwork? This action cannot be undone.'
        )
    ) {
        const { error } = await deleteArtworkAction(id);
        if (error) {
            alert(`Error: ${error.message}`);
        } else {
            alert('Artwork deleted successfully!');
            // Refresh or remove from list
        }
    }
};
```

### Date Input Pattern

```typescript
// Use native <input type="date"> for MVP
// Format: YYYY-MM-DD (ISO date string)

<input
    type="date"
    {...register('start_date')}
    className="border-2 border-black rounded px-3 py-2"
/>

// In Zod schema:
start_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Invalid date format'),

// Future: Upgrade to react-datepicker or similar library
```

### Slug Generation Utility

```typescript
// src/lib/utils/slug.ts
export function generateSlug(text: string): string {
    return text
        .toLowerCase()
        .trim()
        .replace(/[^\w\s-]/g, '') // Remove special chars
        .replace(/\s+/g, '-') // Replace spaces with hyphens
        .replace(/-+/g, '-') // Replace multiple hyphens with single
        .replace(/^-+|-+$/g, ''); // Remove leading/trailing hyphens
}

// Usage in form:
const titleValue = watch('title');
useEffect(() => {
    if (titleValue && !slugManuallyEdited) {
        setValue('slug', generateSlug(titleValue));
    }
}, [titleValue, slugManuallyEdited, setValue]);
```

### Pagination Pattern (Server Component)

```typescript
// src/app/admin/orders/page.tsx
export default async function OrdersPage({
    searchParams,
}: {
    searchParams: { page?: string; status?: string };
}) {
    const page = parseInt(searchParams.page || '1');
    const status = searchParams.status || 'all';
    const limit = 20;
    const offset = (page - 1) * limit;

    const { data: orders, error } = await getAllOrders(limit, offset, { status });
    const totalPages = Math.ceil((orders?.length || 0) / limit);

    return (
        <div>
            <h1>Orders</h1>

            {/* Filter by status */}
            <div className="mb-4">
                <Link href="/admin/orders?page=1">All</Link>
                <Link href="/admin/orders?page=1&status=pending">Pending</Link>
                <Link href="/admin/orders?page=1&status=shipped">Shipped</Link>
            </div>

            <OrdersList orders={orders} />

            {/* Pagination */}
            <div className="mt-4 flex gap-2">
                {page > 1 && (
                    <Link href={`/admin/orders?page=${page - 1}&status=${status}`}>
                        Previous
                    </Link>
                )}
                <span>Page {page} of {totalPages}</span>
                {page < totalPages && (
                    <Link href={`/admin/orders?page=${page + 1}&status=${status}`}>
                        Next
                    </Link>
                )}
            </div>
        </div>
    );
}
```

### Mock Admin Session for Tests

```typescript
// __tests__/utils/mockSession.ts
export function mockAdminSession(role: 'admin' | 'super_admin' = 'admin') {
    const session = {
        userId: 'test-user-id',
        adminId: 'test-admin-id',
        name: 'Test Admin',
        role: role,
        expiresAt: Date.now() + 900000, // 15 minutes
    };

    Object.defineProperty(document, 'cookie', {
        value: `admin_session=${encodeURIComponent(JSON.stringify(session))}`,
        writable: true,
        configurable: true,
    });

    return session;
}

// Usage in tests:
beforeEach(() => {
    mockAdminSession('super_admin');
});
```

---

**End of Phase 3 Specification**
